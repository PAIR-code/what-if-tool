<!--
@license
Copyright 2018 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../iron-icons/av-icons.html" />
<link rel="import" href="../iron-icons/communication-icons.html" />
<link rel="import" href="../iron-collapse/iron-collapse.html" />
<link rel="import" href="../iron-icons/editor-icons.html" />
<link rel="import" href="../iron-icons/hardware-icons.html" />
<link rel="import" href="../iron-icons/iron-icons.html" />
<link rel="import" href="../iron-pages/iron-pages.html" />
<link rel="import" href="../paper-button/paper-button.html" />
<link rel="import" href="../paper-dialog/paper-dialog.html" />
<link rel="import" href="../paper-toggle-button/paper-toggle-button.html" />
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../paper-icon-button/paper-icon-button.html" />
<link rel="import" href="../paper-input/paper-input.html" />
<link rel="import" href="../paper-item/paper-item.html" />
<link rel="import" href="../paper-listbox/paper-listbox.html" />
<link rel="import" href="../paper-progress/paper-progress.html" />
<link rel="import" href="../paper-radio-button/paper-radio-button.html" />
<link rel="import" href="../paper-radio-group/paper-radio-group.html" />
<link rel="import" href="../paper-slider/paper-slider.html" />
<link rel="import" href="../paper-tabs/paper-tab.html" />
<link rel="import" href="../paper-tabs/paper-tabs.html" />
<link rel="import" href="../paper-toast/paper-toast.html" />
<link rel="import" href="../tf-backend/tf-backend.html" />
<link rel="import" href="../tf-dashboard-common/dashboard-style.html" />
<link rel="import" href="../tf-dashboard-common/tf-dashboard-layout.html" />
<link rel="import" href="../tf-dashboard-common/tf-option-selector.html" />
<link rel="import" href="../tf-imports/polymer.html" />
<link rel="import" href="./wit-inference-panel.html" />
<link rel="import" href="../tf-tensorboard/plugin-dialog.html" />
<link rel="import" href="../tf-tensorboard/registry.html" />
<link rel="import" href="../vz-bar-chart/vz-bar-chart.html" />
<link rel="import" href="../vz-line-chart2/vz-line-chart2.html" />
<link rel="import" href="./wit-attribution-table.html" />
<link rel="import" href="./wit-confusion-matrix.html" />
<link rel="import" href="./wit-example-viewer.html" />
<link rel="import" href="./wit-inference-viewer.html" />
<link
  rel="import"
  href="../facets-dive/components/facets-dive/facets-dive.html"
/>
<link
  rel="import"
  href="../facets-overview/components/facets-overview/facets-overview.html"
/>
<!--
  A frontend that displays a set of editable examples and enables inference of those examples,
  visualizing the results.
-->
<dom-module id="wit-dashboard">
  <template>
    <style id="linter-paper-button-style">
      /**
       * This style preserves the styling previous to
       * https://github.com/PolymerElements/paper-button/pull/115
       * This change can break the layout of paper-button content.
       * Remove this style to apply the change, more details at b/70528356.
       */
      paper-button {
        display: inline-block;
        text-align: center;
        font-family: inherit;
      }
    </style>
    <style>
      :host {
        font-family: 'Roboto', 'Noto', sans-serif;
        --paper-tab-ink: var(--tb-orange-dark);
        --wit-color-gray300: #dadce0;
      }

      [hidden] {
        display: none !important;
      }

      #classification {
        width: 40%;
      }

      .example-holder {
        width: 100%;
      }

      .inference-section-holder {
        display: flex;
        margin-top: 6px;
        margin-right: 6px;
      }

      .inference-section {
        width: 100%;
        border: 1px solid var(--wit-color-gray300);
      }

      .inference-viewer {
        max-height: 35%;
        flex-grow: 1;
      }

      .compare-inference-viewer {
        border-left: 1px solid var(--wit-color-gray300);
      }

      .tf-option-selector-0 .content-wrapper.tf-option-selector > * {
        width: 40%;
      }

      paper-progress {
        --paper-progress-active-color: var(--tb-orange-strong);
      }

      #progress {
        position: absolute;
        top: 60px;
        left: 0;
        width: 100%;
      }

      .pdplot-progress {
        width: 100%;
      }

      .noexamples {
        position: absolute;
        top: 75px;
        left: 30px;
      }

      .center {
        position: relative;
      }

      .info-text {
        font-size: 14px;
        color: #3c4043;
        letter-spacing: 0.25px;
        line-height: 20px;
        margin: 12px auto;
      }

      .pd-info-text {
        font-size: 18px;
        color: #3c4043;
        line-height: 24px;
        padding-top: 12px;
        padding-right: 4px;
        padding-left: 12px;
      }

      .pd-no-features-text {
        font-size: 18px;
        color: #3c4043;
        padding: 12px 48px;
      }

      .accept-button-holder {
        display: flex;
        flex-direction: row-reverse;
      }

      .settings-button {
        margin-top: 4px;
      }

      .datapoint-right-controls-holder .control {
        flex-shrink: 0;
      }

      .button {
        font-size: 13px;
        margin: 10px 0 0 0;
        background-color: var(--tb-orange-strong);
        color: white;
      }

      .button[disabled] {
        background-color: #ccc;
      }

      .input-and-tooltip {
        display: flex;
      }

      .label-vocab-path-input {
        flex-grow: 1;
      }

      .threshold-dropdown {
        display: block;
        width: 150px;
        min-width: 150px;
        padding-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
      }

      .short-dropdown {
        display: inline-block;
        width: 100px;
        min-width: 50px;
        padding-right: 5px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
      }

      .slider-label {
        margin-top: 8px;
      }

      .facet-label {
        --paper-input-container-underline: {
          display: none;
        }
        --paper-input-container-input: {
          font-weight: 500;
        }
      }

      .slider {
        width: 280px;
        --paper-slider-input: {
          width: 80px;
        }
      }

      .slider-model-one {
        --paper-slider-knob-color: #12b5ce;
        --paper-slider-active-color: #12b5ce;
      }

      .slider-model-two {
        --paper-slider-knob-color: #fa7817;
        --paper-slider-active-color: #fa7817;
      }

      paper-dialog.inference-settings {
        padding: 20px;
        width: 40%;
        max-width: 40%;
        overflow-y: auto;
        border-radius: 10px;
      }

      .dashboard-layout {
        display: flex;
        height: 100%;
        background-color: white;
      }

      .center {
        width: 60%;
      }

      .side-holder {
        position: relative;
        width: 40%;
        display: flex;
      }

      .side-content {
        padding-left: 5px;
        width: calc(100% - 10px);
        display: flex;
        flex-direction: column;
      }

      .side-tabs {
        display: flex;
        height: calc(100% - 50px);
      }

      .datapoint-tab {
        display: flex;
        width: 100%;
        overflow: auto;
      }

      .config-tab {
        width: 100%;
        display: flex;
      }

      .config-side-content {
        padding-left: 5px;
        width: 30%;
        overflow-y: auto;
        border-right: 1px solid var(--wit-color-gray300);
      }

      .config-main-content {
        width: 70%;
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
      }

      .stats-tab {
        width: 100%;
        display: flex;
        overflow: auto;
      }

      .pd-tab {
        width: 100%;
        padding: 5px 10px;
      }

      .pd-plots-header {
        height: 52px;
        min-height: 52px;
        max-height: 52px;
        border-bottom: solid 2px var(--wit-color-gray300);
        display: flex;
        justify-content: space-between;
      }

      .pdplots-holder {
        flex-grow: 1;
        overflow-y: overlay;
        background: #f8f9fa;
      }

      .pd-range-hyphen {
        padding-right: 6px;
        padding-top: 8px;
      }

      .pd-range-control {
        border-bottom: solid 1px #fcc934;
        border-top: none;
        border-left: none;
        border-right: none;
        height: 36px;
        width: 104px;
        margin-right: 6px;
      }

      #overview {
        max-height: 100%;
        height: 100%;
      }

      .inference-header.heading {
        background: #e4f7fb;
      }

      .right-side {
        position: absolute;
        right: 0;
        top: 0;
      }

      .right-side-performance-tab {
        margin: 4px;
      }

      wit-confusion-matrix {
        display: block;
      }

      .datapoint-controls-holder.datapoint-control-buttons-holder {
        padding-left: 2px;
      }

      .datapoint-controls-holder.datapoint-control-search-holder {
        padding-left: 10px;
      }

      .datapoint-controls-holder {
        border-bottom: 1px solid var(--wit-color-gray300);
        display: flex;
        flex-grow: 0;
        flex-shrink: 0;
        justify-content: space-between;
        margin-left: 1px;
      }

      .datapoint-left-controls-holder {
        display: flex;
        flex-wrap: wrap;
      }

      .datapoint-right-controls-holder {
        display: flex;
        flex-direction: row-reverse;
        overflow: hidden;
      }

      .tf-category-pane {
        flex-grow: 1;
      }

      .tf-category-pane-content {
        flex-wrap: wrap;
        flex-grow: 1;
        padding: 12px;
        border: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-bottom-left-radius: 2px;
        border-bottom-right-radius: 2px;
        background: white;
      }

      :host vz-line-chart2 {
        margin: 12px 12px 12px 24px;
        height: 180px;
        width: 300px;
        display: inline-block;
      }

      :host vz-bar-chart {
        margin: 12px 12px 12px 24px;
        height: 240px;
        width: 450px;
        display: inline-block;
      }

      .pd-input-container {
        display: block;
        flex-grow: 0;
        padding: 12px 48px 24px 24px;
        background: #fef7e0;
        border: solid 1px #fde293;
      }

      .style-input {
        width: 50px;
        text-align: right;
        background: white;
      }

      .feature-container-holder {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background: white;
        display: none;
        flex-direction: column;
      }

      .datapoint-control-filter-input {
        border-radius: 2px;
        max-width: 60%;
        --paper-input-container: {
          padding: 4px 6px 2px 4px;
        }
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868b;
        }
      }

      .datapoint-control-filter-input iron-icon {
        color: #9ba0a6;
      }

      .feature-search-input {
        padding-top: 3px;
        flex-grow: 1;
        max-width: 150px;
      }

      .num-buckets-input {
        width: 45px;
        margin-right: 8px;
      }

      .control-button {
        background-color: white;
        border: 1px solid var(--wit-color-gray300);
        color: var(--tb-orange-dark);
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .control-button[disabled] {
        color: #5f6368;
        background-color: #f4f4f4;
      }

      .main-button {
        background-color: var(--tb-orange-dark);
        border: 1px solid var(--tb-orange-dark);
        color: white;
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .main-button[disabled] {
        background-color: lightgray;
        border: 1px solid lightgray;
        color: gray;
      }

      .optimize-threshold-button {
        margin: 5px 0;
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
      }

      .close-partial-deps-button {
        margin: 10px;
      }

      paper-tabs {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        --paper-tabs-selection-bar-color: var(--tb-orange-dark);
      }

      paper-tab {
        font-size: 14px;
        font-weight: 400;
        padding: 0 24px;
        letter-spacing: 0.1px;
      }

      paper-tab:not(.iron-selected) {
        color: #3c4043;
      }

      paper-tab.iron-selected {
        color: #202124;
        font-weight: 500;
      }

      .perfs-holder {
        display: flex;
        width: 100%;
        flex-wrap: wrap;
        margin: 4px;
        position: relative;
        padding-left: 28px;
      }

      .perf-holder {
        margin: 8px;
        position: relative;
      }

      .regression-attr-holder {
        padding-left: 48px;
        position: relative;
      }

      .perf-curve-x-label {
        position: absolute;
        bottom: 2px;
        left: 138px;
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
        width: 120px;
        text-align: center;
      }

      .perf-curve-y-label {
        position: absolute;
        left: 44px;
        bottom: 54px;
        transform: rotate(270deg);
        transform-origin: left bottom;
        font-size: 12px;
        color: #5f6368;
        width: 120px;
        text-align: center;
      }

      .flex {
        display: flex;
      }

      .space-between {
        justify-content: space-between;
      }

      .flex-wrap {
        display: flex;
        flex-wrap: wrap;
      }

      .optimize-text {
        margin: 5px 0;
        color: grey;
        font-size: 14px;
      }

      .threshold-cost-input {
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868b;
        }
      }

      .bold {
        font-weight: 500;
      }

      .indent {
        margin-left: 10px;
      }

      .feature-breakdown {
        margin-left: 12px;
      }

      .optimize-selection-button {
        margin-left: 0;
        margin-bottom: 5px;
      }

      .reg-table-category {
        text-align: left;
      }

      .reg-table-value {
        text-align: right;
      }

      .subfeature-table {
        margin-left: 10px;
      }

      .counterfactual-button-intro {
        padding: 7px 0 0 10px;
      }

      .main-vertical {
        width: 100%;
      }

      .main-bottom-bar {
        height: 52px;
        min-height: 52px;
        flex-grow: 0;
        display: flex;
        /* box-shadow: 0 2px 5px grey;
        margin-bottom: 3px; */
        border-bottom: solid 1px #dadce0;
        justify-content: space-between;
      }

      .main-content {
        height: 100%;
      }

      .dist-switch {
        display: flex;
        margin-top: 0;
      }

      .distance-vis-dropdown {
        margin-top: 0;
      }

      #distancedialog {
        width: 30%;
      }

      #distancedialog .buttons {
        color: #f57c00;
      }

      paper-radio-button {
        --paper-radio-button-label: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-radio-button-unchecked-color: #3c4043;
        --paper-radio-button-unchecked-ink-color: #3c4043;
        --paper-radio-button-checked-color: #3c4043;
        --paper-radio-button-checked-ink-color: #3c4043;
      }

      paper-icon-button {
        color: #5f6368;
      }

      paper-icon-button[disabled] {
        color: #9aa0a6;
      }

      .resizer {
        display: table;
        height: 100%;
        width: 8px;
        border-left: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        cursor: pointer;
      }

      .example-status {
        font-size: 12px;
        color: #5f6368;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 20px;
      }

      .example-id-label {
        padding: 9px 5px 9px 0;
      }

      .example-id-input {
        width: 70px;
        padding-top: 3px;
      }

      .heading-and-card {
        border: 1px solid lightgray;
        margin-right: 5px;
        margin-top: 5px;
        padding-top: 1px;
      }

      .editor-heading-and-card {
        flex: 1;
        overflow-y: overlay;
      }

      .heading {
        color: #5f6368;
        position: relative;
        padding: 10px 8px;
        background-color: #fef7e0;
        border-bottom: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-left: none;
        border-right: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        width: 100%;
        text-align: left;
      }

      .card {
        padding: 0 10px 5px;
      }

      .no-padding-card {
        padding: 0;
      }

      .tooltip {
        --paper-tooltip: {
          font-size: 16px;
        }
        --paper-tooltip-delay-out: 2000ms;
      }

      .comment-icon {
        width: 30px;
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        margin-top: 10px;
        color: var(--tb-orange-dark);
      }

      .arrow-icon {
        width: 50px;
        height: 50px;
        min-width: 50px;
        min-height: 50px;
        color: var(--tb-orange-dark);
      }

      .pd-arrow-icon {
        width: 40px;
        height: 40px;
        min-width: 40px;
        min-height: 40px;
        margin-top: 5px;
        color: grey;
      }

      .pd-toggle {
        margin: 0 8px 0 20px;
      }

      .pd-entry-container {
        display: flex;
        flex-direction: row-reverse;
        justify-content: space-between;
        flex-grow: 1;
      }

      .info-icon {
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
        margin-top: 10px;
        color: grey;
      }

      .info-icon.cf-info-icon {
        margin-top: 12px;
      }

      .info-icon.thresh-info-icon {
        margin-top: -3px;
        vertical-align: middle;
      }

      .info-icon.pd-info-icon {
        margin-top: 15px;
      }

      .info-icon.threshold-info-icon {
        margin-top: 0;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .info-icon.mean-attrs-info-icon {
        margin-top: -1px;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .info-icon.performance-info-icon {
        margin-top: 18px;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .no-padding {
        padding: 0;
      }

      .resize-icon {
        display: table-cell;
        vertical-align: middle;
        color: grey;
        width: 10px;
        height: 10px;
        min-width: 10px;
        min-height: 10px;
      }

      .help-text {
        color: #5f6368;
        font-size: 10px;
        max-width: 200px;
      }

      .help-title {
        color: #007b7c;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
      }

      .help-title-margin {
        margin-top: 14px;
      }

      .help-title-margin-button {
        margin-top: 4px;
      }

      .help-title-margin-title {
        margin-top: 7px;
      }

      .dialog-link {
        color: #5f6368;
        font-size: 10px;
        font-style: italic;
        text-decoration: underline;
        cursor: pointer;
      }

      .perf-curve-text {
        color: #3c4043;
        font-size: 14px;
        margin-bottom: -10px;
      }

      .conf-text {
        margin-bottom: 8px;
        color: #3c4043;
        font-size: 14px;
      }

      .dialog-text {
        font-style: normal;
        text-align: left;
      }

      .dialog-title {
        font-size: 14px;
        font-weight: 500;
      }

      .title-width {
        width: 250px;
        padding-right: 16px;
      }

      .datapoint-info-holder {
        margin: 24px auto;
        max-width: 380px;
        padding: 24px;
      }

      .onboarding-header {
        color: #202124;
        font-size: 22px;
        margin-bottom: 28px;
      }

      .onboarding-text {
        color: #3c4043;
        font-size: 14px;
        margin-bottom: 20px;
      }

      .control-info-header {
        color: #3c4043;
        font-size: 14px;
        font-weight: 500;
        margin-top: 10px;
        margin-bottom: 15px;
      }

      .control-info-text {
        color: #3c4043;
        font-size: 14px;
        margin-bottom: 15px;
        max-width: 460px;
      }

      .button-prefix-label {
        margin: 12px 0 0 12px;
        color: grey;
        font-size: 14px;
      }

      .border-right {
        border-right: 1px solid var(--wit-color-gray300);
      }

      paper-dialog {
        color: #3c4043;
        border-radius: 10px;
        max-width: 600px;
      }

      .main-button.run-button {
        padding: 5px;
        flex-grow: 1;
      }

      .doc-image {
        width: 128px;
        height: 96px;
        border: 1px solid var(--wit-color-gray300);
      }

      .control-divider {
        margin: 5px 0 5px 5px;
        width: 5px;
        border-left: 1px solid var(--wit-color-gray300);
      }

      .optimization-radio {
        display: block;
        padding: 7px;
      }

      .optimization-radio-group {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
      }

      .infer-info {
        margin-left: 30px;
      }

      .scroll-x {
        overflow-x: auto;
      }

      .perf-table-clickable {
        cursor: pointer;
      }

      .perf-table-title-row {
        background: white;
        width: 100%;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: 52px;
        justify-content: space-between;
      }
      .perf-table-title {
        color: #3c4043;
        font-size: 18px;
        margin-left: 14px;
        margin-top: 16px;
      }
      .perf-table-sort-menu {
        margin-top: -10px;
      }
      .perf-table-header {
        background: white;
        width: 100%;
        font-weight: 500;
        color: #80868b;
        font-size: 14px;
        line-height: 16px;
        letter-spacing: 0.25;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: min-content;
        padding-top: 12px;
        padding-bottom: 4px;
      }

      .perf-table-entries-holder {
        overflow-y: overlay;
        flex-grow: 1;
      }

      .perf-table-entry {
        background: white;
        color: #3c4043;
        font-size: 14px;
      }

      .perf-table-entry.perf-table-entry-trivial {
        background: #f4f4f4;
      }

      .perf-table-entry-expanded {
        display: flex;
        flex-wrap: wrap;
        width: 100%;
        border-left: 1px solid var(--wit-color-gray300);
        border-bottom: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        background: white;
      }

      .perf-table-row {
        width: 100%;
        display: flex;
        background: white;
        position: relative;
        border-bottom: solid 1px var(--wit-color-gray300);
      }

      .perf-table-row-expanded {
        width: 100%;
        display: flex;
        border-top: 1px solid var(--wit-color-gray300);
        border-radius: 2px;
        background: white;
        position: relative;
        padding-bottom: 8px;
      }

      .regression-perf-table-entry {
        background: white;
        color: #3c4043;
        font-size: 14px;
        border-bottom: solid 1px var(--wit-color-gray300);
      }

      .regression-perf-table-row {
        width: 100%;
        display: flex;
        background: white;
        position: relative;
      }

      .feature-name-text {
        font-weight: 500;
        font-size: 14px;
      }

      .perf-table-text-entry {
        height: 40px;
        padding-top: 16px;
      }
      .perf-table-num-entry {
        height: 40px;
        padding-top: 16px;
        text-align: right;
      }
      .perf-table-arrow {
        min-width: 40px;
        width: 40px;
        margin-top: 8px;
      }
      .perf-table-val {
        width: 30%;
      }
      .perf-table-count {
        width: 10%;
        margin-right: 20px;
        text-align: right;
      }
      .perf-table-model {
        min-width: 100px;
        width: 100px;
      }
      .perf-table-model-single {
        display: none;
      }
      .perf-table-threshold {
        width: 280px;
        min-width: 280px;
        text-align: center;
      }
      .perf-table-error {
        width: 15%;
        text-align: right;
      }
      .perf-table-sq-error {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-fp {
        width: 15%;
        text-align: right;
      }
      .perf-table-fn {
        width: 15%;
        text-align: right;
      }
      .perf-table-acc {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-f1 {
        width: 10%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-button {
        margin-top: 10px;
      }

      .perf-sort-box {
        display: flex;
        flex-direction: row-reverse;
      }
      .counterfactual-toggle {
        margin: 4px 4px 4px 6px;
        padding-top: 4px;
        --paper-toggle-button-checked-bar-color: #81c995;
      }
      .counterfactual-delta {
        display: flex;
        margin-right: 6px;
      }
      .counterfactual-delta label {
        padding-top: 12px;
        margin-left: 8px;
        margin-right: 4px;
        font-size: 14px;
        color: rgb(60, 64, 67);
      }
      .counterfactual-delta paper-slider {
        height: 40px;
        --paper-slider-active-color: #81c995;
        --paper-slider-knob-color: #81c995;
        --paper-slider-input-container-input: {
          font-size: 14px;
          color: rgb(60, 64, 67);
        }
      }
      .datapoint-button {
        color: #202124;
        background: #fde293;
      }
      .infer-button {
        color: white;
        background: #128eaf;
      }
      .flex-grow {
        flex-grow: 1;
      }
      .flex-row-reverse {
        flex-direction: row-reverse;
      }
      .threshold-info-holder {
        margin-top: -2px;
      }
      .tabs {
        padding-left: 32px;
        text-transform: none;
      }
      .rotated-icon {
        transform: rotate(270deg);
        padding-right: 0;
      }
      .normal-icon {
        padding-top: 0;
      }
      .datapoint-control-button {
        width: 28px;
        height: 28px;
        padding: 4px;
        margin-top: 4px;
      }
      .pd-holder {
        position: relative;
        width: 300px;
      }
      .pd-y-label {
        color: #5f6368;
        font-size: 12px;
        left: -20px;
        padding: 0px;
        position: absolute;
        top: 80px;
        transform: rotate(270deg);
      }
      .pd-x-label {
        bottom: 0;
        color: #5f6368;
        font-size: 12px;
        overflow: hidden;
        padding: 0 0 0 40px;
        position: absolute;
        text-align: center;
        text-overflow: ellipsis;
        width: 100%;
        white-space: nowrap;
      }
      paper-toggle-button {
        font-size: 14px;
        --paper-toggle-button-checked-button-color: white;
        --paper-toggle-button-label-color: #3c4043;
      }
      .button-and-progress-holder {
        margin-top: 4px;
        position: relative;
      }
      .sort-progress {
        position: absolute;
        top: 8px;
        left: 7px;
        width: 120px;
        --paper-progress-active-color: var(--tb-orange-strong);
      }
      #attributionLegend {
        width: 160px;
        height: 32px;
        margin-top: 8px;
        margin-right: 8px;
      }
    </style>
    <tf-plugin-dialog id="initialDialog"></tf-plugin-dialog>
    <paper-dialog
      id="inferencesettings"
      class="inference-settings"
      opened="[[!local]]"
    >
      <wit-inference-panel
        inference-address="{{inferenceAddress}}"
        model-name="{{modelName}}"
        examples-path="{{examplesPath}}"
        model-type="{{modelType}}"
        model-version="{{modelVersion}}"
        model-signature="{{modelSignature}}"
        max-examples="{{maxExamples}}"
        label-vocab-path="{{labelVocabPath}}"
        multi-class="{{multiClass}}"
        sampling-odds="{{samplingOdds}}"
        sequence-examples="{{sequenceExamples}}"
        max-classes-to-display="{{maxInferenceEntriesPerRun}}"
        use-predict-api="{{usePredictApi}}"
        predict-output-tensor="{{predictOutputTensor}}"
        predict-input-tensor="{{predictInputTensor}}"
      >
      </wit-inference-panel>
      <div class="accept-button-holder">
        <paper-button
          on-tap="getExamplesAndCloseSettings_"
          class="main-button"
          disabled$="[[shouldDisableGetExamplesButton_(examplesPath, maxExamples)]]"
        >
          Accept
        </paper-button>
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
      </div>
    </paper-dialog>
    <paper-dialog id="deletedialog">
      <p>Are you sure you want to delete the selected datapoint?</p>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
        <paper-button
          dialog-confirm
          autofocus
          on-tap="deleteDatapoint_"
          class="main-button"
          >Delete</paper-button
        >
      </div>
    </paper-dialog>
    <paper-dialog id="distancedialog">
      <h2>Create similarity feature</h2>
      <paper-input
        value="{{facetDistFeatureName}}"
        label="Metric name"
        class="datapoint-control-filter-input"
      >
      </paper-input>
      <div class="radiolabel">Distance type</div>
      <paper-radio-group class="dist-switch" selected="{{facetDistSwitch}}">
        <paper-radio-button
          class="dist-radio"
          name="L1"
          disabled$="[[customDistanceFunctionSet]]"
          >L1</paper-radio-button
        >
        <paper-radio-button
          class="dist-radio"
          name="L2"
          disabled$="[[customDistanceFunctionSet]]"
          >L2</paper-radio-button
        >
        <paper-radio-button
          class="dist-radio"
          name="Custom"
          hidden$="[[!customDistanceFunctionSet]]"
          >User-specified</paper-radio-button
        >
      </paper-radio-group>
      <template is="dom-if" if="[[!shouldHideCounterfactualValueSelector_(attributions, customDistanceFunctionSet)]]">
        <div class="radiolabel">Distance based on</div>
        <paper-radio-group class="dist-switch" selected="{{distanceValueSwitch}}">
          <paper-radio-button
            class="dist-radio"
            name="values"
            >Feature values</paper-radio-button
          >
          <paper-radio-button
            class="dist-radio"
            name="attribution"
            >Attributions</paper-radio-button
          >
        </paper-radio-group>
      </template>
      <paper-dropdown-menu
        label="Apply to datapoints visualization"
        class="threshold-dropdown distance-vis-dropdown"
      >
        <paper-listbox
          slot="dropdown-content"
          selected="{{facetDistSetting}}"
          attr-for-selected="name"
        >
          <paper-item name="colorBy">Color By</paper-item>
          <paper-item name="horizontalFacet">X-Axis Binning</paper-item>
          <paper-item name="verticalFacet">Y-Axis Binning</paper-item>
          <paper-item name="horizontalPosition">X-Axis Scatter</paper-item>
          <paper-item name="verticalPosition">Y-Axis Scatter</paper-item>
        </paper-listbox>
      </paper-dropdown-menu>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
        <paper-button
          dialog-confirm
          autofocus
          on-tap="requestAddDistanceMetric"
          class="main-button"
          >Apply</paper-button
        >
      </div>
    </paper-dialog>
    <div class="dashboard-layout">
      <div class="main-vertical">
        <div class="main-content">
          <div class="main-bottom-bar">
            <div class="datapoint-left-controls-holder">
              <paper-tabs class="tabs" noink selected="{{sideTabSelected}}">
                <paper-tab>Datapoint editor</paper-tab>
                <paper-tab
                  >[[getPerformanceTabTitle(modelType, multiClass)]]</paper-tab
                >
                <paper-tab>Features</paper-tab>
              </paper-tabs>
            </div>
            <div class="datapoint-right-controls-holder">
              <a
                target="_blank"
                class="control"
                href="https://pair-code.github.io/what-if-tool/learn"
                rel="noreferrer"
              >
                <paper-icon-button
                  icon="help-outline"
                  class="settings-button"
                  title="What-If Tool documentation"
                ></paper-icon-button>
              </a>
              <paper-icon-button
                icon="settings"
                on-tap="settingsClicked_"
                class="settings-button control"
                title="What-If Tool settings"
                disabled$="[[local]]"
              ></paper-icon-button>
              <div class="example-status">[[exampleStatusStr]]</div>
            </div>
          </div>
          <iron-pages class="side-tabs" selected="{{sideTabSelected}}">
            <div class="datapoint-tab">
              <div class="side-holder" id="side">
                <div class="side-content">
                  <div class="heading-and-card">
                    <button class="heading" on-tap="toggleContextTools">
                      Visualize
                      <div class="right-side right-side-performance-tab">
                        <iron-icon
                          icon="[[getExpandCollapseIcon(openedContextTools)]]"
                          class="expand-collapse-button"
                        ></iron-icon>
                      </div>
                    </button>
                    <iron-collapse
                      class="no-padding-card"
                      id="collapsecontexttools"
                      opened="{{openedContextTools}}"
                    >
                      <paper-radio-group selected="{{visMode}}">
                        <paper-radio-button name="dive"
                          >Datapoints</paper-radio-button
                        >
                        <paper-radio-button name="pd"
                          >Partial dependence plots</paper-radio-button
                        >
                      </paper-radio-group>
                      <div class="flex-wrap">
                        <div title="Select a datapoint to use this feature">
                          <paper-toggle-button
                            class="counterfactual-toggle"
                            checked="{{showNearestCounterfactual}}"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                          >
                            Nearest counterfactual
                          </paper-toggle-button>
                        </div>
                        <paper-icon-button
                          icon="info-outline"
                          class="info-icon no-padding"
                          on-tap="openDialog"
                        >
                        </paper-icon-button>
                        <paper-dialog
                          class="dialog-text"
                          horizontal-align="auto"
                          vertical-align="auto"
                        >
                          <div class="dialog-title">
                            Nearest counterfactual (neighbor of different
                            classification)
                          </div>
                          <div>
                            Compares the selected datapoint with its nearest
                            neighbor from a different classification using L1 or
                            L2 distance. If a custom distance function is set,
                            it uses that function instead.
                          </div>
                          <div>
                            <a
                              target="_blank"
                              class="control"
                              href="https://pair-code.github.io/what-if-tool/learn/tutorials/counterfactual"
                              rel="noreferrer"
                            >
                              Explore a tutorial on using counterfactuals.
                            </a>
                          </div>
                        </paper-dialog>
                        <paper-radio-group
                          selected="{{nearestCounterfactualDist}}"
                        >
                          <paper-radio-button
                            name="L1"
                            disabled$="[[customDistanceFunctionSet]]"
                            >L1</paper-radio-button
                          >
                          <paper-radio-button
                            name="L2"
                            disabled$="[[customDistanceFunctionSet]]"
                            >L2</paper-radio-button
                          >
                          <paper-radio-button
                            name="Custom"
                            hidden$="[[!customDistanceFunctionSet]]"
                            >Custom distance</paper-radio-button
                          >
                        </paper-radio-group>
                        <paper-dropdown-menu
                          label="Calculate using:"
                          no-label-float
                          class="short-dropdown"
                          hidden$="[[shouldHideCounterfactualValueSelector_(attributions, customDistanceFunctionSet)]]"
                        >
                          <paper-listbox
                            class="dropdown-content"
                            slot="dropdown-content"
                            selected="{{nearestCounterfactualValueIndex}}"
                          >
                            <paper-item>Feature values</paper-item>
                            <paper-item>Attributions</paper-item>
                          </paper-listbox>
                        </paper-dropdown-menu>
                        <template is="dom-if" if="[[isRegression_(modelType)]]">
                          <div
                            title="Minimum distance in inferred value to consider counterfactual"
                            class="counterfactual-delta"
                          >
                            <label>Threshold</label>
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="auto"
                            >
                              <div class="dialog-title">
                                Counterfactual threshold
                              </div>
                              <div>
                                For regression, a neighbor point is considered
                                as a different classification if the difference
                                in inferred value is equal or greater than the
                                selected threshold.<br />
                                The threshold is initialized to the standard
                                deviation of the inferred values.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn/"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on understanding model performance.
                                </a>
                              </div>
                            </paper-dialog>
                            <paper-slider
                              editable
                              value="{{minCounterfactualValueDist}}"
                              max="[[maxCounterfactualValueDist]]"
                              disabled$="[[!showNearestCounterfactual]]"
                            ></paper-slider>
                          </div>
                        </template>
                        <paper-dropdown-menu
                          label="Model:"
                          no-label-float
                          class="short-dropdown"
                          hidden$="[[shouldHideModelSelector_(parsedModelNames)]]"
                        >
                          <paper-listbox
                            class="dropdown-content"
                            slot="dropdown-content"
                            selected="{{nearestCounterfactualModelIndex}}"
                          >
                            <template
                              is="dom-repeat"
                              items="[[parsedModelNames]]"
                            >
                              <paper-item
                                >[[getLabeledModelName_(item)]]</paper-item
                              >
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                      </div>
                      <div title="Select a datapoint to use this feature">
                        <div class="flex">
                          <paper-button
                            class="control-button datapoint-button"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="showDistanceClicked_"
                            alt="Create similarity feature"
                            title="Creates a feature that shows similarity to selected datapoint"
                          >
                            Create similarity feature
                          </paper-button>
                          <paper-icon-button
                            icon="info-outline"
                            class="info-icon cf-info-icon no-padding"
                            on-tap="openDialog"
                          >
                          </paper-icon-button>
                          <paper-dialog
                            class="dialog-text"
                            horizontal-align="auto"
                            vertical-align="auto"
                          >
                            <div class="dialog-title">
                              Create similarity feature
                            </div>
                            <div>
                              Calculates the distance between the selected
                              datapoint and all other datapoint. Creates a new feature to visualize
                              in the datapoints visualization.
                            </div>
                            <div>
                              <a
                                target="_blank"
                                class="control"
                                href="https://pair-code.github.io/what-if-tool/learn/tutorials/counterfactual"
                                rel="noreferrer"
                              >
                                Explore a tutorial on using similarity.
                              </a>
                            </div>
                          </paper-dialog>
                        </div>
                      </div>
                    </iron-collapse>
                  </div>
                  <div class="heading-and-card editor-heading-and-card">
                    <button class="heading">
                      [[getDatapointEditorTitle(selectedExampleNum,
                      comparedIndices)]]
                    </button>
                    <div class="no-padding-card">
                      <div
                        class="datapoint-controls-holder datapoint-control-buttons-holder"
                      >
                        <div class="datapoint-left-controls-holder">
                          <paper-icon-button
                            class="datapoint-control-button"
                            icon="chevron-left"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="selectPrevDatapoint_"
                            alt="select previous datapoint"
                            title="Select previous datapoint"
                          >
                          </paper-icon-button>
                          <paper-icon-button
                            class="datapoint-control-button"
                            icon="chevron-right"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="selectNextDatapoint_"
                            alt="select next datapoint"
                            title="Select next datapoint"
                          >
                          </paper-icon-button>
                          <div title="Edit a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="history"
                              on-tap="resetDatapoint_"
                              alt="undo changes"
                              title="Undo changes"
                              disabled$="[[shouldDisableReset_(selectedExampleAndInference.changed)]]"
                            >
                            </paper-icon-button>
                          </div>
                          <div title="Select a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="content-copy"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="copyDatapoint_"
                              alt="duplicate datapoint"
                              title="Duplicate datapoint"
                            >
                            </paper-icon-button>
                          </div>
                          <div title="Select a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="delete"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="deleteDatapointDialog_"
                              alt="delete datapoint"
                              title="Delete datapoint"
                            >
                            </paper-icon-button>
                          </div>
                          <div class="control-divider"></div>
                          <paper-input
                            value="{{featureSearchValue}}"
                            label="Search features"
                            class="datapoint-control-filter-input feature-search-input"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            no-label-float
                          >
                            <iron-icon
                              icon="icons:search"
                              slot="prefix"
                            ></iron-icon>
                          </paper-input>
                          <div
                            class="flex"
                            hidden="[[!hasAttributions_(attributions)]]"
                          >
                            <div class="control-divider"></div>
                            <paper-dropdown-menu
                              label="Feature sort order"
                              class="short-dropdown"
                              no-label-float
                            >
                              <paper-listbox
                                slot="dropdown-content"
                                selected="{{exampleFeatureSortOrder}}"
                                attr-for-selected="name"
                              >
                                <paper-item name="alphabetical"
                                  >Alphabetical by features</paper-item
                                >
                                <paper-item name="attribution"
                                  >Descending attribution</paper-item
                                >
                                <paper-item name="reverse-attribution"
                                  >Ascending attribution</paper-item
                                >
                                <paper-item name="absolute-attribution"
                                  >Absolute attribution</paper-item
                                >
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <svg id="attributionLegend"></svg>
                            <paper-dropdown-menu
                              label="Model:"
                              no-label-float
                              class="short-dropdown"
                              hidden$="[[!hasMultipleModelAttributions_(attributions)]]"
                            >
                              <paper-listbox
                                class="dropdown-content"
                                slot="dropdown-content"
                                selected="{{attributionModelIndex}}"
                              >
                                <template
                                  is="dom-repeat"
                                  items="[[parsedModelNames]]"
                                >
                                  <paper-item
                                    >[[getLabeledModelName_(item)]]</paper-item
                                  >
                                </template>
                              </paper-listbox>
                            </paper-dropdown-menu>
                          </div>
                        </div>
                        <div class="datapoint-right-controls-holder"></div>
                      </div>
                      <template
                        is="dom-if"
                        if="[[hasSelected(selectedExampleAndInference)]]"
                      >
                        <div class="example-and-inference-holder">
                          <wit-example-viewer
                            class="example-holder"
                            json="{{selectedExampleAndInference.example}}"
                            compare-json="{{counterfactualExampleAndInference.example}}"
                            on-example-change="exampleChange_"
                            id="viewer"
                            display-mode="[[exampleDisplayMode]]"
                            feature-search-value="{{featureSearchValue}}"
                            compare-title="[[compareTitle]]"
                            saliency="[[attribution]]"
                            show-saliency
                            readonly="[[!areExamplesEditable_(modelName, inferenceAddress)]]"
                            sort-order="[[exampleFeatureSortOrder]]"
                            min-sal="[[minAttribution]]"
                            max-sal="[[maxAttribution]]"
                            colors="[[attributionColorScale]]"
                            highlight-differences="[[showNearestCounterfactual]]"
                            text-color-function="[[attributionTextColorFunction]]"
                          >
                          </wit-example-viewer>
                        </div>
                      </template>
                      <template
                        is="dom-if"
                        if="[[!hasSelected(selectedExampleAndInference)]]"
                      >
                        <div class="datapoint-info-holder">
                          <div class="datapoint-info-content">
                            <div class="flex space-between">
                              <div class="onboarding-header">
                                Select a datapoint to begin exploring model
                                behavior for your selection.
                              </div>
                            </div>
                            <div class="onboarding-text">
                              <span class="bold">Edit</span>
                              Edit a selected datapoint and click on "predict" to see changes in model prediction. Compare datapoints to their counterfactuals or visualize feature attributions where available.
                            </div>
                            <div class="onboarding-text">
                              <span class="bold">Visualize:</span>
                              Switch between visualizing datapoints and
                              exploring partial dependence plots to gain
                              insights into your model's behavior. Explore
                              counterfactuals or see how similar (or different)
                              the rest of your dataset is from your selection.
                            </div>
                          </div>
                        </div>
                      </template>
                    </div>
                  </div>
                  <div class="inference-section-holder">
                    <div class="inference-section">
                      <button
                        class="inference-header heading"
                        on-tap="toggleInferenceResults"
                      >
                        <div class="flex">
                          <div>
                            [[getInferTitle(selectedExampleNum,
                            comparedIndices)]]
                          </div>
                          <div class="right-side right-side-performance-tab">
                            <iron-icon
                              icon="[[getExpandCollapseIcon(openedInferenceResults)]]"
                              class="expand-collapse-button"
                            ></iron-icon>
                          </div>
                        </div>
                      </button>
                      <iron-collapse
                        class="no-padding-card"
                        id="collapseinference"
                        opened="{{openedInferenceResults}}"
                      >
                        <div title="Select and edit a datapoint to use this feature">
                          <paper-button
                            on-tap="inferClicked_"
                            class="control-button infer-button flex-grow"
                            disabled$="[[shouldDisableInferButton_(examplesAndInferences, modelName, inferenceAddress, updatedExample)]]"
                          >
                            Predict
                          </paper-button>
                        </div>
                        <div class="flex">
                          <template
                            is="dom-if"
                            if="[[hasSelected(selectedExampleAndInference)]]"
                          >
                            <wit-inference-viewer
                              class="inference-viewer"
                              inferences="[[selectedExampleAndInference.inferences]]"
                              id$="[[getInferenceHolderId_()]]"
                              model-type="[[modelType]]"
                              model-names="[[parsedModelNames]]"
                              max-entries-per-run="[[maxInferenceEntriesPerRun]]"
                            >
                            </wit-inference-viewer>
                          </template>
                          <template
                            is="dom-if"
                            if="[[counterfactualExampleAndInference]]"
                          >
                            <wit-inference-viewer
                              class="inference-viewer compare-inference-viewer"
                              inferences="[[counterfactualExampleAndInference.inferences]]"
                              model-type="[[modelType]]"
                              model-names="[[parsedModelNames]]"
                              max-entries-per-run="[[maxInferenceEntriesPerRun]]"
                            >
                            </wit-inference-viewer>
                          </template>
                        </div>
                      </iron-collapse>
                    </div>
                  </div>
                </div>
                <div class="resizer" id="resizer">
                  <iron-icon icon="av:pause" class="resize-icon"></iron-icon>
                </div>
              </div>
              <div class="center" slot="center" id="center">
                <facets-dive
                  id="dive"
                  data="[[visdata]]"
                  selected-indices="[[selected]]"
                  compared-indices="[[comparedIndices]]"
                  on-selected-indices-changed="selectedIndicesChanged_"
                  on-stats-changed="statsChanged_"
                  hide-info-card="true"
                  sprite-image-width="32"
                  sprite-image-height="32"
                  fit-grid-aspect-ratio-to-viewport="true"
                  stable-colors="true"
                >
                </facets-dive>
                <div id="noexamples" class="noexamples info-text">
                  Datapoints and their inference results will be displayed here.
                </div>
                <paper-progress
                  indeterminate
                  id="progress"
                  hidden="[[loadingBarHidden_]]"
                >
                </paper-progress>
                <div class="feature-container-holder" id="partialplotholder">
                  <div class="pd-plots-header">
                    <div class="flex">
                      <div class="pd-info-text">Partial Dependence Plots</div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon pd-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">Partial Dependence Plots</div>
                        <div>
                          Partial dependence plots visualize the change in
                          prediction results for different valid values of a feature.
                        </div>
                        <div>
                          For numeric features, you can set the minimum and
                          maximum values to visualize.
                        </div>
                        <div>
                          For string features, the most popular feature values are shown as alternatives to the feature value for the selected datapoint.
                        </div>
                        <div>
                          If the datapoint contains multiple feature values for a feature, each feature value is visualized as a single plot. You can override which feature values are visualized by specifying the indices for partial dependence plots.
                        </div>
                        <div>
                          When the global toggle is turned on, the plots show the average effect of changing a single feature across all datapoints. When it is turned off, the plots show the effect of changing a single feature on the selected datapoint.
                        </div>
                        <div>
                          <a
                            target="_blank"
                            class="control"
                            href="https://pair-code.github.io/what-if-tool/learn/"
                            rel="noreferrer"
                          >
                            Explore tutorials on using the What-If Tool.
                          </a>
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="button-and-progress-holder">
                      <paper-button
                        class="control-button datapoint-button"
                        disabled$="[[shouldDisableSortFeaturesButton(partialDepPlotEligibleFeatures, isSortingEligibleFeatures)]]"
                        on-tap="sortPdFeatures_"
                        alt="Sort by variation"
                        title="Sort by variation"
                      >
                      Sort by variation
                      </paper-button>
                      <paper-progress
                        class="sort-progress"
                        hidden="[[!isSortingEligibleFeatures]]"
                        indeterminate
                      ></paper-progress>
                    </div>
                    <paper-toggle-button
                      class="pd-toggle"
                      checked="{{globalPdPlots}}"
                      on-change="hideAllPdElements_"
                      disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                    >
                      Global partial dependence plots
                    </paper-toggle-button>
                  </div>
                  <template
                    is="dom-if"
                    if="[[!areTherePdPlotFeatures_(partialDepPlotEligibleFeatures)]]"
                  >
                    <div class="pd-no-features-text">
                      Features for partial dependence plots unavailable in the loaded dataset.
                    </div>
                  </template>
                  <div class="pdplots-holder">
                    <template
                      is="dom-repeat"
                      items="[[partialDepPlotEligibleFeatures]]"
                    >
                      <div
                        class="feature-container"
                        data-feature-name$="[[item.name]]"
                      >
                        <div class$="[[getPerfTableEntryClass(item)]]">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class="pd-row-arrow rotated-icon"
                              icon="arrow-drop-down"
                              on-tap="categoryPaneClicked"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable tf-category-pane perf-table-text-entry"
                            on-tap="categoryPaneClicked"
                          >
                            [[item.name]]
                          </div>
                        </div>
                        <div
                          class="pd-entry-container perf-table-entry-expanded"
                          hidden
                        >
                          <div
                            class="pd-input-container"
                            hidden$="[[shouldHidePdInputContainer(item, selected)]]"
                          >
                            <div
                              class="range-input-container"
                              hidden$="[[item.samples]]"
                            >
                              <div
                                class="info-text"
                                title="set a range of values to visualize in the partial dependence plot(default values are automatically inferred)."
                                alt="set a range of values to visualize in the partial dependence plot"
                              >
                                Set range of values to visualize
                              </div>
                              <div class="flex">
                                <input
                                  type="number"
                                  class="style-input x-min pd-range-control"
                                  value="[[item.observedMin]]"
                                  title="The minimum value to test (default value is automatically inferred)."
                                  on-input="pdInputChanged"
                                />
                                <div class="pd-range-hyphen">-</div>
                                <input
                                  type="number"
                                  class="style-input x-max pd-range-control"
                                  value="[[item.observedMax]]"
                                  title="The maximum value to test (default value is automatically inferred)."
                                  on-input="pdInputChanged"
                                />
                              </div>
                            </div>
                            <div
                              class="feature-index-container"
                              hidden$="[[shouldHideFeatureIndicesSelector(item.name, selected)]]"
                              title="An optional printer-page-style pattern like '0,2,4-6' to select the indices of the feature values to generate plots for. Useful for features with many repeated fields."
                            >
                              <div class="info-text">
                                Set feature indices <i>(optional)</i>
                              </div>
                              <input
                                type="text"
                                class="style-input feature-index-pattern pd-range-control"
                                on-input="pdInputChanged"
                              />
                            </div>
                          </div>
                          <div class="tf-category-pane-content"></div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>
            <div class="config-tab">
              <div class="config-side-content">
                <div class="heading-and-card">
                  <button
                    class="inference-header heading"
                    on-tap="toggleTrueLabelSetup"
                  >
                    Configure
                    <div class="right-side right-side-performance-tab">
                      <iron-icon
                        icon="[[getExpandCollapseIcon(openedTrueLabel)]]"
                        class="expand-collapse-button"
                      ></iron-icon>
                    </div>
                  </button>
                  <iron-collapse
                    class="card"
                    id="collapsetruelabel"
                    opened="{{openedTrueLabel}}"
                  >
                    <template
                      is="dom-if"
                      if="[[shouldShowLabelDropdown_(stats)]]"
                    >
                      <div class="flex">
                        <paper-dropdown-menu
                          label="Ground Truth Feature"
                          class="threshold-dropdown"
                        >
                          <paper-listbox
                            slot="dropdown-content"
                            selected="{{selectedLabelFeature}}"
                            attr-for-selected="name"
                          >
                            <template
                              is="dom-repeat"
                              items="[[getFeatureList_(stats)]]"
                            >
                              <paper-item name="[[item]]"
                                >[[getFeatureName_(item)]]</paper-item
                              >
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                        <div>
                          <div class="help-title help-title-margin">
                            What is ground truth?
                          </div>
                          <div class="help-text">
                            <div>
                              The feature that your model is trying to predict.
                              <span class="dialog-link" on-tap="openDialog"
                                >More.
                              </span>
                              <paper-dialog
                                class="dialog-text"
                                horizontal-align="auto"
                                vertical-align="auto"
                              >
                                <div class="dialog-title">
                                  Ground Truth Feature
                                </div>
                                <div>
                                  Select the feature that represents the ground truth for the model's prediction to investigate the model's performance overall or on intersections of other available features by comparing the model's prediction to the ground truth feature.
                                </div>
                                <div>
                                  <a
                                    target="_blank"
                                    class="control"
                                    href="https://pair-code.github.io/what-if-tool/learn/"
                                    rel="noreferrer"
                                  >
                                    Explore tutorials on analyzing performance.
                                  </a>
                                </div>
                              </paper-dialog>
                            </div>
                          </div>
                        </div>
                      </div>
                      <template
                        is="dom-if"
                        if="[[shouldShowCostRatio_(selectedLabelFeature, modelType, multiClass)]]"
                      >
                        <div class="flex">
                          <paper-input
                            value="{{incorrectPredCostRatio}}"
                            label="Cost Ratio (FP/FN)"
                            type="number"
                            class="threshold-cost-input"
                          >
                          </paper-input>
                          <div>
                            <div class="help-title help-title-margin">
                              What is cost ratio?
                            </div>
                            <div class="help-text">
                              <div>
                                The cost of false positives relative to false
                                negatives. Required for optimization.
                                <span class="dialog-link" on-tap="openDialog"
                                  >More.
                                </span>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="auto"
                                  vertical-align="auto"
                                >
                                  <div class="dialog-title">
                                    What is cost ratio?
                                  </div>
                                  <div>
                                    This tells the tool how to optimize the
                                    classification thresholds when you use the
                                    optimization strategy controls.
                                  </div>
                                  <div>
                                    1.00 = false positives are equally as costly
                                    as false negatives.
                                  </div>
                                  <div>
                                    4.00 = false positives are 4 times more
                                    costly than false negatives
                                  </div>
                                  <div>
                                    0.25 = false negatives are 4 times more
                                    costly than false positives.
                                  </div>
                                  <div>
                                    <a
                                      target="_blank"
                                      class="control"
                                      href="https://pair-code.github.io/what-if-tool/learn"
                                      rel="noreferrer"
                                    >
                                      Explore tutorials on analyzing performance.
                                    </a>
                                  </div>
                                </paper-dialog>
                              </div>
                            </div>
                          </div>
                        </div>
                      </template>
                      <template
                        is="dom-if"
                        if="[[shouldShowFeatureDropdown_(stats)]]"
                      >
                        <div class="flex">
                          <paper-dropdown-menu
                            label="Slice by"
                            class="threshold-dropdown"
                          >
                            <paper-listbox
                              slot="dropdown-content"
                              selected="{{selectedBreakdownFeature}}"
                              attr-for-selected="name"
                            >
                              <template
                                is="dom-repeat"
                                items="[[getFeatureList_(stats)]]"
                              >
                                <paper-item name="[[item]]"
                                  >[[getFeatureName_(item)]]</paper-item
                                >
                              </template>
                            </paper-listbox>
                          </paper-dropdown-menu>
                          <template
                            is="dom-if"
                            if="[[isNumericFeature_(selectedBreakdownFeature)]]"
                          >
                            <paper-input
                              min="2"
                              value="{{numPrimaryBuckets}}"
                              label="Buckets"
                              type="number"
                              class="num-buckets-input"
                            ></paper-input>
                          </template>
                          <div>
                            <div class="help-title help-title-margin">
                              What does slicing do?
                            </div>
                            <div class="help-text">
                              <div>
                                Shows the model's performance on datapoints 
                                grouped by each value of the selected feature.
                              </div>
                            </div>
                          </div>
                        </div>
                        <div class="flex">
                          <template
                            is="dom-if"
                            if="[[shouldShowSecondFeatureDropdown_(selectedBreakdownFeature)]]"
                          >
                            <paper-dropdown-menu
                              label="Slice by (secondary)"
                              class="threshold-dropdown"
                            >
                              <paper-listbox
                                slot="dropdown-content"
                                selected="{{selectedSecondBreakdownFeature}}"
                                attr-for-selected="name"
                              >
                                <template
                                  is="dom-repeat"
                                  items="[[getFeatureList_(stats)]]"
                                >
                                  <paper-item name="[[item]]"
                                    >[[getFeatureName_(item)]]</paper-item
                                  >
                                </template>
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <template
                              is="dom-if"
                              if="[[isNumericFeature_(selectedSecondBreakdownFeature)]]"
                            >
                              <paper-input
                                min="2"
                                value="{{numSecondaryBuckets}}"
                                label="Buckets"
                                type="number"
                                class="num-buckets-input"
                              ></paper-input>
                            </template>
                          </template>
                        </div>
                      </template>
                    </template>
                  </iron-collapse>
                </div>
                <template
                  is="dom-if"
                  if="[[isBinaryClassification_(modelType, multiClass)]]"
                >
                  <div class="heading-and-card">
                    <button
                      class="inference-header heading"
                      on-tap="toggleExplorerSetup"
                    >
                      Fairness
                      <div class="right-side right-side-performance-tab">
                        <iron-icon
                          icon="[[getExpandCollapseIcon(openedExplorer)]]"
                          class="expand-collapse-button"
                        ></iron-icon>
                      </div>
                    </button>
                    <iron-collapse
                      class="card"
                      id="collapseexplorer"
                      opened="{{openedExplorer}}"
                    >
                      <template
                        is="dom-if"
                        if="[[shouldShowFeatureDropdown_(stats)]]"
                      >
                        <div
                          class="control-info-header help-title-margin-button"
                        >
                          Apply an optimization strategy
                        </div>
                        <div class="control-info-text">
                          Select a strategy to automatically set classification thresholds, based on the set cost ratio and data slices. Manually altering thresholds or changing cost ratio will revert the strategy to 'custom thresholds'.
                        </div>
                        <paper-radio-group
                          class="optimization-radio-group"
                          selected="{{optimizationSelected}}"
                        >
                          <paper-radio-button
                            name="custom"
                            class="optimization-radio"
                            id="customthresh"
                            >Custom thresholds
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Custom thresholds</div>
                              <div>
                                Set your own thresholds using the threshold
                                sliders.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="unaware"
                            class="optimization-radio"
                            >Single threshold
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Single threshold</div>
                              <div>
                                Optimize a single threshold for all datapoints
                                based on the specified cost ratio.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn/"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="demoparity"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Demographic parity
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Demographic parity</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve demographic parity.
                              </div>
                              <div>
                                Demographic parity means that similar
                                percentages of datapoints from each slice are
                                predicted as positive classifications.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn/"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="equalopp"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Equal opportunity
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Equal opportunity</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve equal opportunity.
                              </div>
                              <div>
                                Equal opportunity means that among those
                                datapoints with the positive ground truth label,
                                there is a similar percentage of positive
                                predictions in each slice.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn/"
                                  rel="noreferrer"
                                >
                                Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="equalacc"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Equal accuracy
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Equal accuracy</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve equal accuracy.
                              </div>
                              <div>
                                Equal accuracy means that there is a similar
                                percentage of correct predictions in each slice.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn/"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="group"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Group thresholds
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Group thresholds</div>
                              <div>
                                Optimize a separate threshold for each slice
                                based on the specified cost ratio.
                              </div>
                              <div>
                                <a
                                  target="_blank"
                                  class="control"
                                  href="https://pair-code.github.io/what-if-tool/learn"
                                  rel="noreferrer"
                                >
                                  Explore tutorials on analyzing performance.
                                </a>
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                        </paper-radio-group>
                      </template>
                    </iron-collapse>
                  </div>
                </template>
              </div>
              <div class="config-main-content">
                <template
                  is="dom-if"
                  if="[[isBinaryClassification_(modelType, multiClass)]]"
                  restamp
                >
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature, optimizationSelected,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Classification Performance Table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance including ROC curves and confusion
                          matrices.
                        </div>
                        <div>
                          Slice the dataset by features and explore model
                          performance by slice.
                        </div>
                        <div>
                          Use the fairness optimization strategies and see the
                          impact on the thresholds and performance of the
                          individual slices.
                        </div>
                        <div>
                          <a
                            target="_blank"
                            class="control"
                            href="https://pair-code.github.io/what-if-tool/learn/"
                            rel="noreferrer"
                          >
                            Explore tutorials on analyzing performance.
                          </a>
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="perf-sort-box">
                      <div>
                        <paper-icon-button
                          icon="unfold-more"
                          class="perf-button"
                          on-tap="expandAllPerformance"
                          alt="expand all slices"
                          title="Expand all slices"
                        >
                        </paper-icon-button>
                        <paper-icon-button
                          icon="unfold-less"
                          class="perf-button"
                          on-tap="collapseAllPerformance"
                          alt="collapse all slices"
                          title="Collapse all slices"
                        >
                        </paper-icon-button>
                      </div>
                      <paper-dropdown-menu
                        label="Sort by"
                        class="threshold-dropdown perf-table-sort-menu"
                      >
                        <paper-listbox
                          slot="dropdown-content"
                          selected="{{selectedFeatureSort}}"
                          attr-for-selected="name"
                        >
                          <template
                            is="dom-repeat"
                            items="[[getFeatureSortBy(modelType, multiClass)]]"
                          >
                            <paper-item name="[[item]]">[[item]]</paper-item>
                          </template>
                        </paper-listbox>
                      </paper-dropdown-menu>
                    </div>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow">
                      <iron-icon class="expand-collapse-button"></iron-icon>
                    </div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class$="[[getPerfTableModelClass(numModels)]]">
                      Model
                    </div>
                    <div class="perf-table-threshold flex">
                      <div>Threshold</div>
                      <div class="threshold-info-holder">
                        <paper-icon-button
                          icon="info-outline"
                          class="info-icon threshold-info-icon no-padding"
                          on-tap="openDialog"
                        >
                        </paper-icon-button>
                        <paper-dialog
                          class="dialog-text"
                          horizontal-align="auto"
                          vertical-align="auto"
                        >
                          <div class="dialog-title">
                            Explore classification performance
                          </div>
                          <div>
                            Use this slider to adjust the classification
                            threshold for this slice. Inference values at or
                            above this threshold are considered a positive
                            classification, while those below this
                            threshold are considered a negative classification.
                          </div>
                          <div>
                            <a
                              target="_blank"
                              class="control"
                              href="https://pair-code.github.io/what-if-tool/learn/"
                              rel="noreferrer"
                            >
                              Explore tutorials on analyzing performance.
                            </a>
                          </div>
                        </paper-dialog>
                      </div>
                    </div>
                    <div class="perf-table-fp">False Positives (%)</div>
                    <div class="perf-table-fn">False Negatives (%)</div>
                    <div class="perf-table-acc">Accuracy (%)</div>
                    <div class="perf-table-f1">F1</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template
                      is="dom-repeat"
                      items="[[featureValueThresholds]]"
                      as="featureValueThreshold"
                    >
                      <div class="perf-table-entry">
                        <div
                          class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]"
                          data-index$="[[index]]"
                        >
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]"
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable perf-table-text-entry feature-name-text"
                            on-tap="togglePerfRow"
                          >
                            [[getPrintableValue_(featureValueThreshold)]]
                          </div>
                          <div
                            class="perf-table-count perf-table-clickable perf-table-num-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getFeatureValueCount(inferenceStats_,
                            featureValueThreshold.threshold,
                            featureValueThreshold)]]
                          </div>
                          <div
                            class$="[[getPerfTableModelClass(numModels)]]"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-clickable"
                              >
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-threshold">
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <paper-slider
                                class$="[[getSliderClass(index)]]"
                                editable="true"
                                min="0"
                                max="1"
                                step="0.01"
                                immediate-value="{{item.threshold}}"
                                value="[[item.threshold]]"
                                on-value-changed="refreshInferencesNoRegen_"
                                on-immediate-value-changed="refreshInferencesNoRegen_"
                                on-down="resetOptimizationSelected_"
                              >
                              </paper-slider>
                            </template>
                          </div>
                          <div
                            class="perf-table-fp perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFPModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-fn perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFNModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-acc perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getAccuracyModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-f1 perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getF1ModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <iron-collapse opened="{{featureValueThreshold.opened}}">
                        <div class="perf-table-entry-expanded flex-row-reverse">
                          <template
                            is="dom-if"
                            if="[[shouldShowFeaturePerfAttributionCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences, attributions)]]"
                          >
                            <div class="perfs-holder">
                              <template
                                is="dom-if"
                                if="[[shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences, attributions)]]"
                              >
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    [[getRocChartTitleForSlice(aucs_, index)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">ROC curve</div>
                                      <div>[[describeRocChart()]]</div>
                                      <div>[[describeRocAuc()]]</div>
                                      <div>
                                        <a
                                          target="_blank"
                                          class="control"
                                          href="https://pair-code.github.io/what-if-tool/learn"
                                          rel="noreferrer"
                                        >
                                          Explore tutorials on analyzing performance.
                                        </a>
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">
                                    False positive rate
                                  </div>
                                  <div class="perf-curve-y-label">
                                    True positive rate
                                  </div>
                                  <vz-line-chart2
                                    id="[[getRocChartId(index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    [[getPrChartTitleForSlice(aucs_, index)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">PR curve</div>
                                      <div>[[describePrChart()]]</div>
                                      <div>[[describePrAuc()]]</div>
                                      <div>
                                        <a
                                          target="_blank"
                                          class="control"
                                          href="https://pair-code.github.io/what-if-tool/learn/"
                                          rel="noreferrer"
                                        >
                                          Explore tutorials on analyzing performance.
                                        </a>
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">Recall</div>
                                  <div class="perf-curve-y-label">Precision</div>
                                  <vz-line-chart2
                                    id="[[getPrChartId(index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                                <div class="perf-holder">
                                  <div class="flex">
                                    <div class="conf-text">Confusion Matrix</div>
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon mean-attrs-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="auto"
                                      vertical-align="auto"
                                    >
                                      <div class="dialog-title">
                                          Confusion Matrix
                                      </div>
                                      <div>
                                          A confusion matrix is a n*n table (where n = number of classes being predicted) that summarizes if a model’s predictions were correct or incorrect. One axis is the model’s predictions, and the other axis is the ground truth.
                                      </div>
                                      <div>
                                        <a
                                          target="_blank"
                                          class="control"
                                          href="https://pair-code.github.io/what-if-tool/learn/"
                                          rel="noreferrer"
                                        >
                                          Explore tutorials on analyzing performance.
                                        </a>
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <template
                                    is="dom-repeat"
                                    items="{{featureValueThreshold.threshold}}"
                                  >
                                    <wit-confusion-matrix
                                      counts="[[getConfusionCountsModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]"
                                      label="[[getConfusionMatrixLabel(index, numModels)]]"
                                      background="[[getConfusionMatrixColor(index)]]"
                                      all-items="[[allConfMatrixLabels]]"
                                    >
                                    </wit-confusion-matrix>
                                  </template>
                                </div>
                              </template>
                              <template
                                is="dom-if"
                                if="[[hasAttributions_(attributions)]]"
                              >
                                <div class="perf-holder">
                                  <div class="flex">
                                    <div class="conf-text">Mean attributions</div>
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon mean-attrs-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="auto"
                                      vertical-align="auto"
                                    >
                                      <div class="dialog-title">
                                        Mean attributions
                                      </div>
                                      <div>
                                        This table shows the average attribution value for each feature across a set of datapoints, ordered from maximum to minimum.
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <wit-attribution-table
                                    attributions="[[getFacetedAttributions(facetedMeanAttributions_, featureValueThreshold)]]"
                                    models="[[parsedModelNames]]"
                                    colors="[[attributionColorScale]]"
                                    text-color-function="[[attributionTextColorFunction]]">
                                  </wit-attribution-table>
                                </div>
                              </template>
                            </div>
                          </template>
                        </div>
                      </iron-collapse>
                    </template>
                    <template
                      is="dom-if"
                      if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]"
                    >
                      <div class="perf-table-entry">
                        <div class="perf-table-row-expanded">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                              class="normal-icon"
                              disabled
                            ></paper-icon-button>
                          </div>
                          <div class="perf-table-val perf-table-text-entry feature-name-text">
                            All datapoints
                          </div>
                          <div class="perf-table-count perf-table-num-entry">
                            [[getFeatureValueCount(inferenceStats_,
                            overallThresholds)]]
                          </div>
                          <div class$="[[getPerfTableModelClass(numModels)]]">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-text-entry">
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-threshold">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <paper-slider
                                class$="[[getSliderClass(index)]]"
                                editable="true"
                                min="0"
                                max="1"
                                step="0.01"
                                immediate-value="{{item.threshold}}"
                                value="[[item.threshold]]"
                                on-value-changed="refreshInferencesNoRegen_"
                                on-immediate-value-changed="refreshInferencesNoRegen_"
                                on-down="resetOptimizationSelected_"
                              >
                              </paper-slider>
                            </template>
                          </div>
                          <div class="perf-table-fp">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFPModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-fn">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFNModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-acc">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getAccuracyModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-f1">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getF1ModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <div class="perf-table-entry-expanded flex-row-reverse">
                        <template
                          is="dom-if"
                          if="[[shouldShowOverallPerfAttributionCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences, attributions)]]"
                        >
                          <div class="perfs-holder">
                            <template
                              is="dom-if"
                              if="[[shouldShowOverallPerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences, attributions)]]"
                            >
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  [[getRocChartTitleOverall(aucs_)]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">ROC curve</div>
                                    <div>[[describeRocChart()]]</div>
                                    <div>[[describeRocAuc()]]</div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">
                                  False positive rate
                                </div>
                                <div class="perf-curve-y-label">
                                  True positive rate
                                </div>
                                <vz-line-chart2
                                  id="rocchart"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  [[getPrChartTitleOverall(aucs_)]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">PR curve</div>
                                    <div>[[describePrChart()]]</div>
                                    <div>[[describePrAuc()]]</div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">Recall</div>
                                <div class="perf-curve-y-label">Precision</div>
                                <vz-line-chart2
                                  id="prchart"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="flex">
                                  <div class="conf-text">Confusion Matrix</div>
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon mean-attrs-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="auto"
                                    vertical-align="auto"
                                  >
                                    <div class="dialog-title">
                                        Confusion Matrix
                                    </div>
                                    <div>
                                        A confusion matrix is a n*n table (where n = number of classes being predicted) that summarizes if a model’s predictions were correct or incorrect. One axis is the model’s predictions, and the other axis is the ground truth.
                                    </div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <template
                                  is="dom-repeat"
                                  items="{{overallThresholds}}"
                                >
                                  <wit-confusion-matrix
                                    counts="[[getConfusionCountsModelIndex(inferenceStats_, overallThresholds, index)]]"
                                    label="[[getConfusionMatrixLabel(index, numModels)]]"
                                    background="[[getConfusionMatrixColor(index)]]"
                                    all-items="[[allConfMatrixLabels]]"
                                  >
                                  </wit-confusion-matrix>
                                </template>
                              </div>
                            </template>
                            <template
                              is="dom-if"
                              if="[[hasAttributions_(attributions)]]"
                            >
                              <div class="perf-holder">
                                <div class="flex">
                                  <div class="conf-text">Mean attributions</div>
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon mean-attrs-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="auto"
                                    vertical-align="auto"
                                  >
                                    <div class="dialog-title">
                                      Mean attributions
                                    </div>
                                    <div>
                                        This table shows the average attribution value for each feature across a set of datapoints, ordered from maximum to minimum.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <wit-attribution-table
                                  attributions="[[meanAttributions_]]"
                                  models="[[parsedModelNames]]"
                                  colors="[[attributionColorScale]]"
                                  text-color-function="[[attributionTextColorFunction]]">
                                </wit-attribution-table>
                              </div>
                            </template>
                          </div>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
                <template
                  is="dom-if"
                  if="[[isMultiClass_(modelType, multiClass)]]"
                  restamp
                >
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getNoThresholdPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Classification performance table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance including confusion matrices.
                        </div>
                        <div>
                          Create slices from intersections in the dataset and explore model performance on slices.
                        </div>
                        <div>
                          <a
                            target="_blank"
                            class="control"
                            href="https://pair-code.github.io/what-if-tool/learn/"
                            rel="noreferrer"
                          >
                            Explore tutorials on analyzing performance.
                          </a>
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="perf-sort-box">
                      <div>
                        <paper-icon-button
                          icon="unfold-more"
                          class="perf-button"
                          on-tap="expandAllPerformance"
                          alt="expand all slices"
                          title="Expand all slices"
                        >
                        </paper-icon-button>
                        <paper-icon-button
                          icon="unfold-less"
                          class="perf-button"
                          on-tap="collapseAllPerformance"
                          alt="collapse all slices"
                          title="Collapse all slices"
                        >
                        </paper-icon-button>
                      </div>
                      <paper-dropdown-menu
                        label="Sort by"
                        class="threshold-dropdown perf-table-sort-menu"
                      >
                        <paper-listbox
                          slot="dropdown-content"
                          selected="{{selectedFeatureSort}}"
                          attr-for-selected="name"
                        >
                          <template
                            is="dom-repeat"
                            items="[[getFeatureSortBy(modelType, multiClass)]]"
                          >
                            <paper-item name="[[item]]">[[item]]</paper-item>
                          </template>
                        </paper-listbox>
                      </paper-dropdown-menu>
                    </div>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow"></div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class$="[[getPerfTableModelClass(numModels)]]">
                      Model
                    </div>
                    <div class="perf-table-acc">Accuracy</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template
                      is="dom-repeat"
                      items="[[featureValueThresholds]]"
                      as="featureValueThreshold"
                    >
                      <div class="perf-table-entry">
                        <div
                          class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]"
                          data-index$="[[index]]"
                        >
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]"
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable perf-table-text-entry feature-name-text"
                            on-tap="togglePerfRow"
                          >
                            [[getPrintableValue_(featureValueThreshold)]]
                          </div>
                          <div
                            class="perf-table-count perf-table-num-entry perf-table-clickable perf-table-text-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getMultiClassFeatureValueCount(inferenceStats_,
                            featureValueThreshold)]]
                          </div>
                          <div
                            class$="[[getPerfTableModelClass(numModels)]]"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-clickable"
                              >
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-acc perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-num-entry"
                              >
                                [[getMultiClassAccuracyModelIndex(inferenceStats_,
                                index, featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <iron-collapse opened="{{featureValueThreshold.opened}}">
                        <div
                          class="perf-table-entry-expanded flex-row-reverse scroll-x"
                        >
                          <template
                            is="dom-if"
                            if="[[shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="flex">
                                  <div class="conf-text">Confusion Matrix</div>
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon mean-attrs-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="auto"
                                    vertical-align="auto"
                                  >
                                    <div class="dialog-title">
                                        Confusion Matrix
                                    </div>
                                    <div>
                                        A confusion matrix is a n*n table (where n = number of classes being predicted) that summarizes if a model’s predictions were correct or incorrect. One axis is the model’s predictions, and the other axis is the ground truth.
                                    </div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <template
                                  is="dom-repeat"
                                  items="[[inferenceStats_]]"
                                  as="inferenceStat"
                                >
                                  <wit-confusion-matrix
                                    counts="[[getMultiClassConfMatrix(inferenceStats_, index, featureValueThreshold)]]"
                                    label="[[getConfusionMatrixLabel(index, numModels)]]"
                                    background="[[getConfusionMatrixColor(index)]]"
                                    all-items="[[allConfMatrixLabels]]"
                                  >
                                  </wit-confusion-matrix>
                                </template>
                              </div>
                            </div>
                            <template
                              is="dom-repeat"
                              items="[[allConfMatrixLabels]]"
                              as="label"
                              index-as="labelInd"
                            >
                              <div class="perfs-holder">
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    [[getRocChartTitleForLabel(aucs_, labelInd, index)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">ROC curve</div>
                                      <div>[[describeRocChart()]]</div>
                                      <div>
                                        For this multi-class classification
                                        problem, we plot one ROC curve for each
                                        class, at each time considering the
                                        class in question as the positive one
                                        and all the others as negatives (<i
                                          >i.e.</i
                                        >
                                        <i>binarized</i> versions of the
                                        problem).
                                      </div>
                                      <div>[[describeRocAuc()]]</div>
                                      <div>
                                        <a
                                          target="_blank"
                                          class="control"
                                          href="https://pair-code.github.io/what-if-tool/learn"
                                          rel="noreferrer"
                                        >
                                          Explore tutorials on analyzing performance.
                                        </a>
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">
                                    False positive rate
                                  </div>
                                  <div class="perf-curve-y-label">
                                    True positive rate
                                  </div>
                                  <vz-line-chart2
                                    id="[[getRocChartLabelId(labelInd, index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    [[getPrChartTitleForLabel(aucs_, labelInd, index)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">PR curve</div>
                                      <div>[[describePrChart()]]</div>
                                      <div>
                                        For this multi-class classification
                                        problem, we plot one PR curve for each
                                        class, at each time considering the
                                        class in question as the positive one
                                        and all the others as negatives (<i
                                          >i.e.</i
                                        >
                                        <i>binarized</i> versions of the
                                        problem).
                                      </div>
                                      <div>[[describePrAuc()]]</div>
                                      <div>
                                        <a
                                          target="_blank"
                                          class="control"
                                          href="https://pair-code.github.io/what-if-tool/learn"
                                          rel="noreferrer"
                                        >
                                          Explore tutorials on analyzing performance.
                                        </a>
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">Recall</div>
                                  <div class="perf-curve-y-label">
                                    Precision
                                  </div>
                                  <vz-line-chart2
                                    id="[[getPrChartLabelId(labelInd, index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                              </div>
                            </template>
                          </template>
                          <template
                            is="dom-if"
                            if="[[hasAttributions_(attributions)]]"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="flex">
                                  <div class="conf-text">Mean attributions</div>
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon mean-attrs-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="auto"
                                    vertical-align="auto"
                                  >
                                    <div class="dialog-title">
                                      Mean attributions
                                    </div>
                                    <div>
                                        This table shows the average attribution value for each feature across a set of datapoints, ordered from maximum to minimum.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <wit-attribution-table
                                  attributions="[[getFacetedAttributions(facetedMeanAttributions_, featureValueThreshold)]]"
                                  models="[[parsedModelNames]]"
                                  colors="[[attributionColorScale]]"
                                  text-color-function="[[attributionTextColorFunction]]">
                                </wit-attribution-table>
                              </div>
                            </div>
                          </template>
                        </div>
                      </iron-collapse>
                    </template>
                    <template
                      is="dom-if"
                      if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]"
                    >
                      <div class="perf-table-entry">
                        <div class="perf-table-row-expanded">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                              class="normal-icon"
                              disabled
                            ></paper-icon-button>
                          </div>
                          <div class="perf-table-val perf-table-text-entry feature-name-text">
                            All datapoints
                          </div>
                          <div class="perf-table-count perf-table-num-entry">
                            [[getMultiClassFeatureValueCount(inferenceStats_)]]
                          </div>
                          <div class$="[[getPerfTableModelClass(numModels)]]">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-text-entry">
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-acc">
                            <template
                              is="dom-repeat"
                              items="[[inferenceStats_]]"
                              as="inferenceStat"
                            >
                              <div
                                class="perf-table-text-entry perf-table-num-entry"
                              >
                                [[getMultiClassAccuracyModelIndex(inferenceStats_,
                                index)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <div
                        class="perf-table-entry-expanded flex-row-reverse scroll-x"
                      >
                        <template
                          is="dom-if"
                          if="[[shouldShowOverallPerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                        >
                          <div class="perfs-holder">
                            <div class="perf-holder">
                              <div class="flex">
                                <div class="conf-text">Confusion Matrix</div>
                                <paper-icon-button
                                  icon="info-outline"
                                  class="info-icon mean-attrs-info-icon no-padding"
                                  on-tap="openDialog"
                                >
                                </paper-icon-button>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="auto"
                                  vertical-align="auto"
                                >
                                  <div class="dialog-title">
                                      Confusion Matrix
                                  </div>
                                  <div>
                                      A confusion matrix is a n*n table (where n = number of classes being predicted) that summarizes if a model’s predictions were correct or incorrect. One axis is the model’s predictions, and the other axis is the ground truth.
                                  </div>
                                  <div>
                                    <a
                                      target="_blank"
                                      class="control"
                                      href="https://pair-code.github.io/what-if-tool/learn/"
                                      rel="noreferrer"
                                    >
                                      Explore tutorials on analyzing performance.
                                    </a>
                                  </div>
                                </paper-dialog>
                              </div>
                              <template
                                is="dom-repeat"
                                items="[[inferenceStats_]]"
                                as="inferenceStat"
                              >
                                <wit-confusion-matrix
                                  counts="[[getMultiClassConfMatrix(inferenceStats_, index)]]"
                                  label="[[getConfusionMatrixLabel(index, numModels)]]"
                                  background="[[getConfusionMatrixColor(index)]]"
                                  all-items="[[allConfMatrixLabels]]"
                                >
                                </wit-confusion-matrix>
                              </template>
                            </div>
                          </div>
                          <template
                            is="dom-repeat"
                            items="[[allConfMatrixLabels]]"
                            as="label"
                            index-as="labelInd"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  [[getRocChartTitleForLabel(aucs_, labelInd, '')]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">ROC curve</div>
                                    <div>[[describeRocChart()]]</div>
                                    <div>
                                      For this multi-class classification
                                      problem, we plot one ROC curve for each
                                      class, at each time considering the class
                                      in question as the positive one and all
                                      the others as negatives (<i>i.e.</i>
                                      <i>binarized</i> versions of the problem).
                                    </div>
                                    <div>[[describeRocAuc()]]</div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">
                                  False positive rate
                                </div>
                                <div class="perf-curve-y-label">
                                  True positive rate
                                </div>
                                <vz-line-chart2
                                  id="[[getRocChartLabelId(label, '')]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  [[getPrChartTitleForLabel(aucs_, labelInd, '')]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">PR curve</div>
                                    <div>[[describePrChart()]]</div>
                                    <div>
                                      For this multi-class classification
                                      problem, we plot one PR curve for each
                                      class, at each time considering the class
                                      in question as the positive one and all
                                      the others as negatives (<i>i.e.</i>
                                      <i>binarized</i> versions of the problem).
                                    </div>
                                    <div>[[describePrAuc()]]</div>
                                    <div>
                                      <a
                                        target="_blank"
                                        class="control"
                                        href="https://pair-code.github.io/what-if-tool/learn/"
                                        rel="noreferrer"
                                      >
                                        Explore tutorials on analyzing performance.
                                      </a>
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">Recall</div>
                                <div class="perf-curve-y-label">Precision</div>
                                <vz-line-chart2
                                  id="[[getPrChartLabelId(label, '')]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                            </div>
                          </template>
                        </template>
                        <template
                          is="dom-if"
                          if="[[hasAttributions_(attributions)]]"
                        >
                          <div class="perfs-holder">
                            <div class="perf-holder">
                              <div class="flex">
                                <div class="conf-text">Mean attributions</div>
                                <paper-icon-button
                                  icon="info-outline"
                                  class="info-icon mean-attrs-info-icon no-padding"
                                  on-tap="openDialog"
                                >
                                </paper-icon-button>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="auto"
                                  vertical-align="auto"
                                >
                                  <div class="dialog-title">
                                    Mean attributions
                                  </div>
                                  <div>
                                    This table shows the average attribution value for each feature across a set of datapoints, ordered from maximum to minimum.
                                  </div>
                                </paper-dialog>
                              </div>
                              <wit-attribution-table
                                attributions="[[meanAttributions_]]"
                                models="[[parsedModelNames]]"
                                colors="[[attributionColorScale]]"
                                text-color-function="[[attributionTextColorFunction]]">
                              </wit-attribution-table>
                            </div>
                          </div>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
                <template is="dom-if" if="[[isRegression_(modelType)]]" restamp>
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getNoThresholdPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Regression Performance Table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance.
                        </div>
                        <div>
                          Create slices from intersections in the dataset and explore model performance by
                          slices.
                        </div>
                      </paper-dialog>
                    </div>
                    <paper-dropdown-menu
                      label="Sort by"
                      class="threshold-dropdown perf-table-sort-menu"
                    >
                      <paper-listbox
                        slot="dropdown-content"
                        selected="{{selectedFeatureSort}}"
                        attr-for-selected="name"
                      >
                        <template
                          is="dom-repeat"
                          items="[[getFeatureSortBy(modelType, multiClass)]]"
                        >
                          <paper-item name="[[item]]">[[item]]</paper-item>
                        </template>
                      </paper-listbox>
                    </paper-dropdown-menu>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow"></div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class="perf-table-error">Mean error</div>
                    <div class="perf-table-error">Median error</div>
                    <div class="perf-table-error">Mean absolute error</div>
                    <div class="perf-table-error">Median absolute error</div>
                    <div class="perf-table-sq-error">Mean squared error</div>
                    <div class="perf-table-sq-error">Median squared error</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template is="dom-repeat" items="[[regressionEntries_]]">
                      <div class="regression-perf-table-entry">
                        <div class="regression-perf-table-row">
                          <div class="perf-table-arrow"></div>
                          <div class="perf-table-val perf-table-text-entry feature-name-text">
                            [[item.name]]
                          </div>
                          <div
                            class="perf-table-count perf-table-num-entry perf-table-text-entry"
                          >
                            [[item.count]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanAbsError)]]
                          </div>
                          <div
                            class="perf-table-sq-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianAbsError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanSquaredError)]]
                          </div>
                          <div
                            class="perf-table-sq-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianSquaredError)]]
                          </div>
                        </div>
                        <template is="dom-if" if="[[hasAttributions_(attributions)]]">
                          <div class="regression-attr-holder">
                            <div class="flex">
                              <div class="conf-text">Mean attributions</div>
                              <paper-icon-button
                                icon="info-outline"
                                class="info-icon mean-attrs-info-icon no-padding"
                                on-tap="openDialog"
                              >
                              </paper-icon-button>
                              <paper-dialog
                                class="dialog-text"
                                horizontal-align="auto"
                                vertical-align="auto"
                              >
                                <div class="dialog-title">
                                  Mean attributions
                                </div>
                                <div>
                                  This table shows the average attribution value for each feature across a set of datapoints, ordered from maximum to minimum.
                                </div>
                              </paper-dialog>
                            </div>
                            <wit-attribution-table
                              attributions="[[getRegressionAttributions(item.name)]]"
                              models="[[parsedModelNames]]"
                              colors="[[attributionColorScale]]"
                              text-color-function="[[attributionTextColorFunction]]">
                            </wit-attribution-table>
                          </div>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
              </div>
            </div>
            <div class="stats-tab">
              <facets-overview
                id="overview"
                search-string="{{featureSearchValue}}"
              ></facets-overview>
            </div>
          </iron-pages>
        </div>
      </div>
    </div>
    <style include="dashboard-style"></style>
  </template>

  <script>
    const maxStringLengthToDecode = 100000;
    const inferenceLabelStr = ' Inference label';
    const inferenceValueStr = ' Inference value';
    const inferenceCorrectStr = ' Inference correct';
    const inferenceErrorStr = ' Inference error';
    const inferenceAbsErrorStr = ' Inference absolute error';
    const inferenceSquaredErrorStr = ' Inference squared error';
    const inferenceScoreStr = ' Inference score';
    const exampleIdKey = ' Datapoint ID';
    // requestDistanceWithCallback can be invoked with the callbacks in this
    // enum. Please add a function to this list if you want it to be invoked
    // at the end of custom distance computation.
    const distanceCallbacks = {
      finalizeClosestCounterfactual: 0,
      finalizeAddDistanceMetric: 1,
    };

    // Special feature names and feature name prefixes and suffixes for parsing
    // inference and attribution information from TFMA-generated input.
    const classificationResultsKey = 'predictions__probabilities';
    const regressionResultsKey = 'predictions';
    const attributionPrefix = 'attributions__';
    const featureForAttributionPrefix = 'features__';

    // Colors for the attribution color scale.
    const posAttributionHighColor = '#3D7078';
    const posAttributionLowColor = '#6A9EA7';
    const neutralAttributionColor = '#FFD8C3';
    const negAttributionLowColor = '#C7696E';
    const negAttributionHighColor = '#943A43';
    const COLOR_INTERPOLATOR = d3.interpolateRgb;
    const LEGEND_WIDTH_PX = 160;
    const LEGEND_HEIGHT_PX = 8;
    const defaultTextColor = '#3c4043';
    const lightTextColor = '#fff';

    function deleteElement(elt) {
      if (elt && elt.parentElement) {
        elt.parentElement.removeChild(elt);
      }
    }

    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    (function() {
      const PLUGIN_NAME = 'whatif';

      Polymer({
        is: 'wit-dashboard',
        properties: {
          // TensorBoard plugin standard.
          _requestManager: {
            type: Object,
            value: () => new tf_backend.RequestManager(),
          },
          _canceller: {
            type: Object,
            value: () => new tf_backend.Canceller(),
          },

          // User-provided fields for WIT plugin from settings dialog.
          examplesPath: {
            type: String,
          },
          modelName: {
            type: String,
            observer: 'modelNameChanged_',
          },
          parsedModelNames: {
            type: String,
          },
          inferenceAddress: {
            type: String,
          },
          modelType: {
            type: String,
          },
          modelSignature: {
            type: String,
          },
          modelVersion: {
            type: String,
          },
          maxExamples: {
            type: Number,
          },
          labelVocabPath: {
            type: String,
          },
          maxInferenceEntriesPerRun: Number,
          // Number of buckets when aggregating numeric features.
          numPrimaryBuckets: {
            type: Number,
            value: 2,
            observer: 'breakdownFeatureSelected_',
          },
          numSecondaryBuckets: {
            type: Number,
            value: 2,
            observer: 'breakdownFeatureSelected_',
          },

          // Inferences from servo.
          inferences: {
            type: Object,
            observer: 'newInferences_',
            value: () => ({}),
          },
          // Extra outputs from inference. A dict with two fields: 'indices' and
          // 'extra'. Indices contains a list of example indices that
          // these new outputs apply to. Extra contains a list of extra output
          // objects, one for each model being inferred. The object for each
          // model is a dict of output data names to lists of the output values
          // for that data, one entry for each example that was inferred upon.
          // 'attributions' is one of these output data which is parsed into the
          // 'attributions' object defined below as a special case. Any other extra
          // data provided are displayed by WIT with each example.
          // @type {indices: Array<number>,
          //        extra: Array<{!Object<string, Array<number|string>>}>}
          extraOutputs: {
            type: Object,
            observer: 'newExtraOutputs_',
          },
          // Attributions from inference. A dict with two fields: 'indices' and
          // 'attributions'. Indices contains a list of example indices that
          // these new attributions apply to. Attributions contains a list of
          // attributions for each of those examples.
          // The attribution object for each example is a dict of feature name
          // to attribution value.
          // The attribution value is one of the following:
          // - A single number representing the attribution to that entire feature
          //   value.
          // - A list of numbers representing the attributions to individual
          //   values of a multivalent feature - such as pixels in an image or
          //   numbers in a list of numbers.
          attributions: {
            type: Object,
            value: {indices: [], attributions: []},
            observer: 'newAttributions_',
          },
          // Stores all attributions for all datapoints for each model, for
          // use in generating global attribution stats.
          // Array<Array<{[feature: string]: number[]}>> with the outer array
          // being datapoints in the dataset, the inner array being model
          // indicies, and the dictionary containing a list of feature
          // attributions for each feature.
          allAttributions_: {
            type: Array,
            value: () => [],
          },
          // Stores for each model the list of features and their mean
          // attributions.
          // Array<Array<{feature: string, mean: number}>> with outer array
          // being model indicies and inner array being features with
          // attributions, sorted by attribution strength.
          meanAttributions_: {
            type: Array,
            value: () => [],
          },
          // When faceting the dataset for performance evaluation, stores for
          // each facet, for each model the list of features and their mean
          // attributions for the datapoints in that facet.
          // {[key: string]: MeanAttributionsArray} with the key being the
          // stringified name of the facet and MeanAttributionsArray being
          // of the type of the meanAttributions_ attribute defined above.
          facetedMeanAttributions_: {
            type: Object,
            value: () => {},
          },
          // Minimum attribution value seen in the data.
          minAttribution: {type: Number, value: 0},
          // Maximum attribution value seen in the data.
          maxAttribution: {type: Number, value: 0},
          // Color scale for attribution coloring.
          attributionColorScale: Object,
          // Examples and their inferences merged into a single list.
          // # Samples -> .inferences -> # Inferences -> # Models -> # Labels
          examplesAndInferences: {
            type: Array,
            value: () => [],
            observer: 'computeSelectedExampleAndInference',
          },
          // The currently selected item from the examplesAndInferences list,
          // selected through clicking in Facets Dive.
          /** @type {?Object} */
          selectedExampleAndInference: {
            type: Object,
          },
          // The closest counterfatual example to the currently selected item,
          // if one is found through the counterfactual button.
          /** @type {?Object} */
          counterfactualExampleAndInference: {
            type: Object,
          },
          // The examples list in the format to provide to Facets Dive.
          // Each element in the list represents a datapoint and is a dictionary
          // with keys being the features and values being the value of a feature,
          // or a list of values for those features that contain more than one
          // feature value.
          visdata: {
            type: Array,
            value: () => [],
          },
          // The selected items list provided by Facets Dive. The What-If Tool
          // only makes use of the first selected item, but Facets Dive itself
          // maintains a list of all selected items and this is bound to that
          // list provided by Facets Dive.
          selected: {
            type: Array,
            value: () => [],
            observer: 'computeSelectedExampleAndInference',
          },
          // The selected item to compare, provided to Facets Dive.
          comparedIndices: {
            type: Array,
            value: () => [],
          },
          // List of strings corresponding to inference numeric labels for
          // classification models, from file at labelVocabPath.
          labelVocab: {
            type: Array,
            value: () => [],
          },
          // True if an example has been updated.
          updatedExample: {
            type: Boolean,
            value: false,
          },
          imageFeatureName: {
            type: String,
            value: 'image/encoded',
            readonly: true,
          },
          // The dataset stats from Facets Dive to be used for the classification
          // threshold logic.
          stats: Object,
          // Feature to see performance breakdowns for the values of.
          selectedBreakdownFeature: {
            type: String,
            value: '',
            observer: 'breakdownFeatureSelected_',
          },
          // Second feature to see performance breakdowns for the values of,
          // crossed with the first selected feature.
          selectedSecondBreakdownFeature: {
            type: String,
            value: '',
            observer: 'breakdownFeatureSelected_',
          },
          // True if a custom distance function is set and is in use.
          customDistanceFunctionSet: {
            type: Boolean,
            value: false,
            observer: 'customDistanceFunctionSetChanged_',
          },
          // Feature for true label.
          selectedLabelFeature: {
            type: String,
            value: '',
            observer: 'labelFeatureSelected_',
          },
          // Choose which model is used for counterfactual computation
          nearestCounterfactualModelIndex: {
            type: Number,
            value: 0,
          },
          // Whether to calculate counterfactuals using feature values (0),
          // or attributions (1).
          nearestCounterfactualValueIndex: {
            type: Number,
            value: 0
          },
          // Choose which model is used for attribution value display
          attributionModelIndex: {
            type: Number,
            value: 0,
            observer: 'setAttributions',
          },
          // Calculated statistics from the inference results.
          inferenceStats_: {
            type: Array,
            value: () => [],
          },
          // Calculated states of AUC for ROC and PR curve charts, keyed by (chartId, modelIndex)
          aucs_: {
            type: Object,
            value: () => {}
          },
          // Array of feature values and their set classification thresholds, for
          // Polymer display purposes.
          featureValueThresholds: {
            type: Array,
            value: () => [],
            observer: 'featureValueThresholdsChanged_',
          },
          // A map of feature name to the featureValueThresholds indices, for quick
          // lookup.
          featureValueThresholdsIndexMap: Object,
          // The default inference label when the classification threshold isn't
          // met.
          defaultInferenceLabel: {
            type: Number,
            value: 0,
            observer: 'refreshInferences_',
          },
          // The classification threshold when it isn't being set on a
          // per-feature-value basis. One per model.
          overallThresholds: {
            type: Array,
            value: () => [],
          },
          // Which side-tab is selected.
          sideTabSelected: {
            type: Number,
            value: 0,
            observer: 'sideTabSelectedChanged_',
          },
          // Boolean for if running in "local" demo mode, meaning this isn't
          // part of a TensorBoard build and has no backend.
          local: {
            type: Boolean,
            value: false,
            observer: 'localChanged_',
          },
          // Atlas URL for "local" demo mode.
          localAtlasUrl: String,
          // List of features for which we can make partial dep plots.
          partialDepPlotEligibleFeatures: {
            type: Array,
            value: () => [], // [{name: 'a_numeric_feature', observedMin: -10,
            //   observedMax: 10},
            // {name: 'a_categorical_feature', samples: []}]
            observer: 'partialDepPlotEligibleFeaturesSet',
          },
          // Features that we are currently creating partial dep plots for.
          partialDepPlotPendingFeatures: {
            type: Array,
            value: () => [],
          },
          // Mode of how individual examples are display in the side panel.
          exampleDisplayMode: {
            type: String,
            value: 'stacked',
          },
          // Search string for feature searching.
          featureSearchValue: String,
          // Ratio of false positive to false negative for grading classification
          // thresholds.
          incorrectPredCostRatio: {
            type: Number,
            value: 1,
            observer: 'costRatioChanged_',
          },
          // If the classification model is a multi-class model.
          multiClass: {
            type: Boolean,
          },
          // If the examples loaded are SequenceExamples.
          sequenceExamples: {
            type: Boolean,
          },
          // Sampling odds (1: load all examples, .2: sample 20% of examples)
          samplingOdds: {
            type: Number,
          },
          // Whether to use the TF Serving Predict API or not.
          usePredictApi: {
            type: Boolean,
          },
          // Name of the output tensor to parse when using the Predict API.
          predictOutputTensor: {
            type: String,
          },
          // Name of the intput tensor to parse when using the Predict API.
          predictInputTensor: {
            type: String,
          },
          // Precision on charts for performance measuring.
          axisPrecision: {
            type: Number,
            value: 2,
          },
          // Stats calculated from the overview stats proto used for determining
          // counterfactual example distance.
          distanceStats_: {
            type: Object,
          },
          // Whether to show distance to selected example by L1 or L2 distance.
          facetDistSwitch: {
            type: String,
            value: 'L1',
          },
          // Whether to show distance to selected example by feature values
          // or by attributions.
          distanceValueSwitch: {
            type: String,
            value: 'values',
          },
          // Facets Dive feature name for distance to the selected example.
          facetDistFeatureName: {
            type: String,
          },
          // All previously-created feature names for distances to selected
          // examples.
          facetDistFeatureNames: {
            type: Array,
            value: () => [],
          },
          // What Facets Dive setting to use to show distance to selected
          // example.
          facetDistSetting: {
            type: String,
            value: 'colorBy',
          },
          exampleStatusStr: {
            type: String,
            value: 'No datapoints loaded yet',
          },
          // The example ID number selected in the text input
          selectedExampleNum: {
            type: Number,
            value: '',
            observer: 'selectedExampleInputChanged_',
          },
          // The max ID number for a selected example.
          selectedExampleMax: Number,
          openedContextTools: {
            type: Boolean,
            value: true,
          },
          openedPerformance: {
            type: Boolean,
            value: true,
          },
          openedTrueLabel: {
            type: Boolean,
            value: true,
          },
          openedExplorer: {
            type: Boolean,
            value: true,
          },
          openedInferenceResults: {
            type: Boolean,
            value: true,
          },
          regressionEntries_: {
            type: Array,
          },
          nearestCounterfactualDist: {
            type: String,
            value: 'L1',
          },
          minCounterfactualValueDist: Number,
          maxCounterfactualValueDist: Number,
          visMode: {
            type: String,
            value: 'dive',
            observer: 'visModeChanged_',
          },
          // The optimization setting selected for setting classification
          // thresholds.
          optimizationSelected: {
            type: String,
            value: 'custom',
            observer: 'optimizationSelectedChanged_',
          },
          compareTitle: {
            type: String,
            value: 'Attribution value(s)',
          },
          // Dictionary of features to feature value attributions for display
          // in the example viewer. Filled in if the selected example contains
          // attribution information.
          attribution: {
            type: Object,
            value: () => ({}),
          },
          // True if showing global PD plots. False if showing individual PD
          // plots.
          globalPdPlots: {
            type: Boolean,
            value: true,
          },
          // Number of models, only updated when user clicks "Accept" in settings
          // pane
          numModels: {
            type: Number,
            readOnly: true,
          },
          // Show nearest counterfactual toggle button setting.
          showNearestCounterfactual: {
            type: Boolean,
            value: false,
          },
          selectedFeatureSort: {
            type: String,
            value: 'Count',
            observer: 'selectedFeatureSortChanged_',
          },
          // Colors for lines and bars in partial dependence plots.
          pdPlotColors: {
            type: Array,
            value: () => [
              d3.color('rgb(31, 119, 180)'),
              d3.color('rgb(255, 127, 14)'),
              d3.color('rgb(44, 160, 44)'),
              d3.color('rgb(214, 39, 40)'),
              d3.color('rgb(148, 103, 189)'),
              d3.color('rgb(140, 86, 75)'),
              d3.color('rgb(227, 119, 194)'),
              d3.color('rgb(127, 127, 127)'),
              d3.color('rgb(188, 189, 34)'),
              d3.color('rgb(23, 190, 207)'),
            ],
          },
          // Transparent version of colors for partial dependence plots for
          // indicating classification threshold values.
          pdPlotTransparentColors: {
            type: Array,
            value: () => [
              d3.color('rgba(31, 119, 180, 0.3)'),
              d3.color('rgba(255, 127, 14, 0.3)'),
              d3.color('rgba(44, 160, 44, 0.3)'),
              d3.color('rgba(214, 39, 40, 0.3)'),
              d3.color('rgba(148, 103, 189, 0.3)'),
              d3.color('rgba(140, 86, 75, 0.3)'),
              d3.color('rgba(227, 119, 194, 0.3)'),
              d3.color('rgba(127, 127, 127, 0.3)'),
              d3.color('rgba(188, 189, 34, 0.3)'),
              d3.color('rgba(23, 190, 207, 0.3)'),
            ],
          },
          // Colors for lines in ROC curves
          rocCurveColors: {
            type: Array,
            value: () => [
              d3.color('rgb(18, 181, 206)'),
              d3.color('rgb(250, 120, 23)'),
            ],
          },
          rocCurveLineColors: {
            type: Array,
            value: () => [
              d3.color('rgba(18, 181, 206, 0.6)'),
              d3.color('rgba(250, 120, 23, 0.6)'),
            ],
          },
          // Colors for confusion matrix backgrounds.
          confMatrixColors: {
            type: Array,
            value: () => [
              d3.color('rgb(18, 181, 206)'),
              d3.color('rgb(250, 120, 23)'),
            ],
          },
          // Dictionary where keys contain all cell labels for confusion
          // matrices.
          allConfMatrixLabels: {
            type: Array,
            value: () => [],
          },
          // Controls if the loading progress bar is hidden from view.
          loadingBarHidden_: {
            type: Boolean,
            value: true,
          },
          isSortingEligibleFeatures: {
            type: Boolean,
            value: false,
          },
          // Sort order for features in the example viewer.
          exampleFeatureSortOrder: {
            type: String,
            value: 'attribution',
          },
          // This object maps each feature to a list of buckets delimiters,
          // used for aggregating numeric features.
          // For instance: `{'age': [10, 30, 60, 90]}` would mean values should
          // be bucketed into either `[10, 30)`, `[30, 60)` or `[60, 90]`.
          featureBucketEdges_: {
            type: Object,
            value: () => ({}),
          },
          // Function to get text colors for attribution values, to be passed
          // to child components that render such text.
          attributionTextColorFunction: {
            type: Object,
            value: () => {
              return function(saliency, minSal, maxSal) {
                const percentile = (saliency - minSal) / (maxSal - minSal);
                let useLightColor = false;
                if (minSal < 0 && maxSal > 0) {
                  useLightColor = percentile < 0.3 || percentile > 0.7;
                } else if (this.minSal < 0) {
                  useLightColor = percentile < 0.6;
                } else {
                  useLightColor = percentile > 0.4;
                }
                return useLightColor ? lightTextColor : defaultTextColor;
              };
            }
          },
        },

        observers: [
          'setFacetDistFeatureName(facetDistSwitch, selected, distanceValueSwitch, attributionModelIndex)',
          'nearestCounterfactualStatusChanged_(showNearestCounterfactual, nearestCounterfactualModelIndex, nearestCounterfactualDist, minCounterfactualValueDist, nearestCounterfactualValueIndex, attributionModelIndex)',
        ],

        // Required function.
        reload: function() {},

        openDialog: function(event) {
          event.stopPropagation();
          const dialog = event.target.parentElement.querySelector(
            'paper-dialog'
          );
          dialog.open();
        },

        ready: function() {
          const side = d3.select(this.$.side);
          const center = d3.select(this.$.center);
          const resizer = this.$.resizer;
          const self = this;

          const dragResize = d3.drag().on('drag', () => {
            // Determine resizer position relative to width of the tool.
            const x = d3.mouse(resizer.parentNode.parentNode)[0];
            const width = resizer.parentNode.parentNode.offsetWidth;
            let perc = (x / width) * 100;

            // Side panel will be a minimum of 20% width.
            perc = Math.max(perc, 20);

            center.style('width', 100 - perc + '%');
            side.style('width', perc + '%');

            // Force the Dive visualization to recompute item positions and handle
            // changed container size.
            self.$.dive.$.vis._updateGridFaceting();
            self.$.dive.$.vis._onIronResize();
          });

          d3.select(resizer).call(dragResize);
        },

        attached: function() {
          // Check if the plugin was created
          this._requestManager
            .request(tf_backend.getRouter().pluginsListing())
            .then((plugins) => {
              if (!(PLUGIN_NAME in plugins)) {
                // The plugin was not created
                this.$.inferencesettings.close();
                this.$.initialDialog.openNoTensorFlowDialog();
              } else {
                // The plugin was created
                this.$.initialDialog.closeDialog();
              }
            });
        },

        settingsClicked_: function() {
          this.$.inferencesettings.toggle();
        },

        localChanged_: function() {
          if (this.local) {
            this.closeSettings_();
          }
        },

        modelNameChanged_: function() {
          this.parsedModelNames = this.modelName
            .split(',')
            .map((str) => str.trim());
          // If any names are identical, then add an index-based postfix
          // to make them unique, for display purposes.
          for (let i = 0; i < this.parsedModelNames.length; i++) {
            const currentName = this.parsedModelNames[i];
            for (let j = i + 1; j < this.parsedModelNames.length; j++) {
              if (this.parsedModelNames[j] == currentName) {
                this.parsedModelNames[i] = currentName + ' ' + (i + 1);
                this.parsedModelNames[j] = currentName + ' ' + (j + 1);
              }
            }
          }
        },

        closeSettings_: function() {
          this.$.inferencesettings.close();
        },

        showDistanceClicked_: function() {
          this.$.distancedialog.toggle();
        },
        customDistanceFunctionSetChanged_: function() {
          if (this.customDistanceFunctionSet) {
            this.nearestCounterfactualDist = 'Custom';
            this.facetDistSwitch = 'Custom';
          } else {
            this.nearestCounterfactualDist = 'L1';
            this.facetDistSwitch = 'L1';
          }
        },

        requestAddDistanceMetric: function() {
          const selected = this.selected[0];
          const params = {
            callbackParams: {featureName: this.facetDistFeatureName},
            distanceParams: {},
          };
          // Custom distance function can only be used when local.
          // If using custom distance function, request distances and return.
          if (this.local && this.customDistanceFunctionSet) {
            this.requestDistanceWithCallback(
              selected,
              distanceCallbacks.finalizeAddDistanceMetric,
              params
            );
            return;
          } else {
            const dists = [];
            const useL2Distance = this.facetDistSwitch == 'L2';
            const useFeatureValues = this.distanceValueSwitch == 'values';
            for (let i = 0; i < this.visdata.length; i++) {
              dists.push(
                this.getDist(
                  this.visdata[selected],
                  this.visdata[i],
                  useL2Distance,
                  useFeatureValues
                )
              );
            }
            this.finalizeAddDistanceMetric(
              selected,
              dists,
              params.callbackParams
            );
          }
        },

        invokeCustomDistanceCallback: function(callbackObj) {
          switch (callbackObj.funId) {
            case distanceCallbacks.finalizeClosestCounterfactual:
              this.finalizeClosestCounterfactual(
                callbackObj.exInd,
                callbackObj.distances,
                callbackObj.params
              );
              break;
            case distanceCallbacks.finalizeAddDistanceMetric:
              this.finalizeAddDistanceMetric(
                callbackObj.exInd,
                callbackObj.distances,
                callbackObj.params
              );
              break;
          }
        },

        finalizeAddDistanceMetric: function(exInd, distances, callbackParams) {
          const facetDistFeatureName = callbackParams.featureName;
          this.facetDistFeatureNames.push(facetDistFeatureName);
          for (let i = 0; i < this.visdata.length; i++) {
            this.visdata[i][facetDistFeatureName] = distances[i];
          }
          this.refreshDive_();
          if (this.facetDistSetting == 'colorBy') {
            this.$.dive.colorBy = facetDistFeatureName;
          } else if (this.facetDistSetting == 'verticalFacet') {
            this.$.dive.verticalFacet = facetDistFeatureName;
          } else if (this.facetDistSetting == 'horizontalFacet') {
            this.$.dive.horizontalFacet = facetDistFeatureName;
          } else if (this.facetDistSetting == 'verticalPosition') {
            this.$.dive.verticalPosition = facetDistFeatureName;
          } else if (this.facetDistSetting == 'horizontalPosition') {
            this.$.dive.horizontalPosition = facetDistFeatureName;
          }
        },

        setFacetDistFeatureName: function(facetDistSwitch, selected,
            distanceValueSwitch, attributionModelIndex) {
          const useModelIndex = this.numModels > 1;
          const distanceDetails = distanceValueSwitch === 'values' ? '' : 
            (this.numModels === 1
              ? ' attributions'
              : ' attributions for model ' +
                this.getModelName_(attributionModelIndex));
          this.facetDistFeatureName =
            ' ' + facetDistSwitch + distanceDetails + ' distance to datapoint ' + selected[0];
        },

        nearestCounterfactualStatusChanged_: function(show) {
          if (show) {
            this.findClosestCounterfactual_();
            this.compareTitle = 'Counterfactual value(s)';
          } else {
            this.compareTitle = 'Attribution value(s)';
            this.comparedIndices = [];
            this.counterfactualExampleAndInference = null;
            this.refreshSelectedDatapoint_();
          }
        },

        refreshSelectedDatapoint_: function() {
          const temp = this.selectedExampleAndInference;
          this.selectedExampleAndInference = null;
          this.selectedExampleAndInference = temp;
        },

        isSameInferenceClass_: function(val1, val2) {
          return this.isRegression_(this.modelType)
            ? Math.abs(val1 - val2) < this.minCounterfactualValueDist
            : val1 === val2;
        },

        adjustMaxCounterfactualValueDist_: function(selected, valueName) {
          this.maxCounterfactualValueDist = Math.max(
            this.stats[valueName].numberMax - this.visdata[selected][valueName],
            this.visdata[selected][valueName] - this.stats[valueName].numberMin
          );
        },

        adjustMinCounterfactualValueDist_: function() {
          const valueName = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          const stat = this.distanceStats_[valueName];
          this.minCounterfactualValueDist = stat ? stat.stdDev : 0;
        },

        finalizeClosestCounterfactual: function(exInd, distances) {
          // Distances are indexed by example ids
          const modelInferenceValueStr = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          if (this.isRegression_(this.modelType)) {
            this.adjustMaxCounterfactualValueDist_(
              exInd,
              modelInferenceValueStr
            );
          }
          let closestDist = Number.POSITIVE_INFINITY;
          let closest = -1;
          for (let i = 0; i < this.visdata.length; i++) {
            // Skip the selected example itself and examples with the same inference class.
            if (
              i === exInd ||
              this.isSameInferenceClass_(
                this.visdata[exInd][modelInferenceValueStr],
                this.visdata[i][modelInferenceValueStr]
              )
            ) {
              continue;
            }
            let dist = distances[i];
            if (dist < closestDist) {
              closestDist = dist;
              closest = i;
            }
          }
          if (closest != -1) {
            // Display the counterfactual in dive and example viewer.
            this.comparedIndices = [closest];
            this.counterfactualExampleAndInference = this.examplesAndInferences[
              closest
            ];
          }
        },

        findClosestCounterfactual_: function() {
          const selected = this.selected[0];
          // Custom distance function can only be used when local.
          // If using custom distance function, request distances and return.
          if (this.local && this.customDistanceFunctionSet) {
            this.requestDistanceWithCallback(
              selected,
              distanceCallbacks.finalizeClosestCounterfactual,
              {callbackParams: {}, distanceParams: {}}
            );
            return;
          }

          const modelInferenceValueStr = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          if (this.isRegression_(this.modelType)) {
            this.adjustMaxCounterfactualValueDist_(
              selected,
              modelInferenceValueStr
            );
          }
          let closestDist = Number.POSITIVE_INFINITY;
          let closest = -1;
          for (let i = 0; i < this.visdata.length; i++) {
            // Skip the selected example itself and examples with the same inference class.
            if (
              i === selected ||
              this.isSameInferenceClass_(
                this.visdata[selected][modelInferenceValueStr],
                this.visdata[i][modelInferenceValueStr]
              )
            ) {
              continue;
            }
            let dist = this.getDist(
              this.visdata[selected],
              this.visdata[i],
              this.nearestCounterfactualDist == 'L2',
              this.nearestCounterfactualValueIndex == 0
            );
            if (dist < closestDist) {
              closestDist = dist;
              closest = i;
            }
          }
          if (closest != -1) {
            // Display the counterfactual in dive and example viewer.
            this.comparedIndices = [closest];
            this.counterfactualExampleAndInference = this.examplesAndInferences[
              closest
            ];
            this.compareTitle = 'Counterfactual value(s)';
          }
        },

        // Call backend for distance computation, backend calls callback function
        // with computed distances and parameters
        // TODO (tolgab) If TensorBoard supports custom distance functions
        // add ability to call into their backend as well (non-local mode).
        requestDistanceWithCallback: function(exInd, callbackFun, params) {
          const urlParams = {
            index: exInd,
            callback: callbackFun,
            params: params,
          };
          this.fire('compute-custom-distance', urlParams);
        },

        /**
         * Gets distance between two examples using L1 or L2 distance.
         */
        getDist: function(a, b, useL2Distance, useFeatureValues) {
          let dist = 0;
          const allKeys = [...new Set([...Object.keys(a), ...Object.keys(b)])];
          for (let featIndex = 0; featIndex < allKeys.length; featIndex++) {
            const feat = allKeys[featIndex];
            // Skip inferred keys, label feature and non-numeric features with
            // only unique values.
            if (
              this.isComputedKeyStr_(feat) ||
              feat == this.selectedLabelFeature ||
              (!this.distanceStats_[feat].isNumeric &&
                this.stats[feat].uniqueCount ==
                this.examplesAndInferences.length)
            ) {
              continue;
            }
            // Skip attributions if using feature values, and skip
            // non-attributions if using attributions instead.
            if ((useFeatureValues && this.isAttributionKeyStr_(feat)) ||
                (!useFeatureValues && !this.isAttributionKeyStr_(feat))) {
              continue;
            }
            // Only use attribution features from currently selected
            // attribution model.
            if (this.numModels > 1 && !useFeatureValues) {
              if (!feat.endsWith(this.getModelName_(
                this.attributionModelIndex))) {
                continue;
              }
            }

            let aVals = a[feat];
            let bVals = b[feat];
            if (!Array.isArray(aVals)) {
              aVals = [aVals];
            }
            if (!Array.isArray(bVals)) {
              bVals = [bVals];
            }
            const maxLength = Math.max(aVals.length, bVals.length);
            let featureTotalDist = 0;
            for (let i = 0; i < maxLength; i++) {
              if (this.distanceStats_[feat].isNumeric) {
                featureTotalDist += this.getNumericDist(
                  aVals[i],
                  bVals[i],
                  this.distanceStats_[feat]
                );
              } else {
                featureTotalDist += this.getCategoricalDist(
                  aVals[i],
                  bVals[i],
                  this.distanceStats_[feat]
                );
              }
            }
            let newDist = featureTotalDist / maxLength;
            if (useL2Distance) {
              newDist *= newDist;
            }
            dist += newDist;
          }
          return dist;
        },

        /** Gets distance between two numeric feature values. */
        getNumericDist: function(a, b, stats) {
          if (a == null || b == null) {
            return 1;
          }
          if (!stats.stdDev) {
            return 0;
          }
          // Return the difference divided by the standard deviation of that
          // feature across all examples.
          return Math.abs((a - b) / stats.stdDev);
        },

        /** Gets distance between two categorical feature values. */
        getCategoricalDist: function(a, b, stats) {
          if (a == null || b == null) {
            return 1;
          }
          if (a == b) {
            return 0;
          }
          // If they are different return the probability that any two examples
          // have the same feature value for this feature.
          return stats.probSameValue;
        },

        visModeChanged_: function(mode) {
          mode == 'dive'
            ? this.hidePartialDependencePlots_()
            : this.showPartialDependencePlots_();
        },

        hidePartialDependencePlots_: function() {
          this.$.partialplotholder.style.display = 'none';
        },

        showPartialDependencePlots_: function() {
          this.$.partialplotholder.style.display = 'flex';
          requestAnimationFrame(() => this.populatePdTabs());
        },

        areTherePdPlotFeatures_: function(partialDepPlotEligibleFeatures) {
          return (
            partialDepPlotEligibleFeatures &&
            partialDepPlotEligibleFeatures.length > 0
          );
        },

        selectedIndicesChanged_: function(event) {
          this.selected = event.detail.value;
          this.setAttributions();
          this.selectedDataUpdated_();
          if (this.showNearestCounterfactual && this.selected.length != 0) {
            this.findClosestCounterfactual_();
          } else {
            this.comparedIndices = [];
          }
        },

        selectNextDatapoint_: function() {
          const id = (this.selected[0] + 1) % this.visdata.length;
          this.$.dive.selectedIndices = [id];
        },

        selectPrevDatapoint_: function() {
          const id =
            (((this.selected[0] - 1) % this.visdata.length) +
              this.visdata.length) %
            this.visdata.length;
          this.$.dive.selectedIndices = [id];
        },

        selectedExampleInputChanged_: function(newDatapoint) {
          if (newDatapoint == null || newDatapoint == '') {
            return;
          }
          const id = +newDatapoint;
          if (isNaN(id) || id < 0 || id >= this.visdata.length) {
            return;
          }
          this.$.dive.selectedIndices = [id];
        },

        setExampleCollapsed_: function() {
          this.exampleDisplayMode = 'grid';
          this.$$('#viewer').expandedFeatures = {};
          this.$$('#viewer').expandAllFeatures = false;
          this.$$('#viewer').refreshExampleViewer();
        },

        setExampleShow_: function() {
          this.exampleDisplayMode = 'grid';
          this.$$('#viewer').expandAllFeatures = true;
        },

        setExampleExpanded_: function() {
          this.exampleDisplayMode = 'stacked';
          this.$$('#viewer').expandAllFeatures = true;
        },

        statsChanged_: function(event) {
          this.stats = event.detail.value;
        },

        isBinaryClassification_: function(modelType, multiClass) {
          return modelType == 'classification' && !multiClass;
        },

        isMultiClass_: function(modelType, multiClass) {
          return modelType == 'classification' && multiClass;
        },

        isRegression_: function(modelType) {
          return modelType == 'regression';
        },

        shouldShowFeatureDropdown_: function(stats) {
          return stats && Object.keys(stats).length > 0;
        },

        shouldShowSecondFeatureDropdown_: function(selectedBreakdownFeature) {
          return selectedBreakdownFeature != '';
        },

        shouldShowLabelDropdown_: function(stats) {
          return stats && Object.keys(stats).length > 0;
        },

        shouldHideModelSelector_: function(modelNames) {
          return !(modelNames && modelNames.length > 1);
        },

        shouldHideCounterfactualValueSelector_: function(
            attributions, customDistanceFunctionSet) {
          return !this.hasAttributions_(attributions) ||
              customDistanceFunctionSet;
        },

        shouldShowOverallPerfCharts_: function(
          selectedLabelFeature,
          selectedBreakdownFeature,
          inferences
        ) {
          return (
            selectedLabelFeature != '' &&
            selectedBreakdownFeature == '' &&
            inferences != null
          );
        },

        shouldShowOverallPerfAttributionCharts_: function(
          selectedLabelFeature,
          selectedBreakdownFeature,
          inferences, attributions
        ) {
          return this.shouldShowOverallPerfCharts_(selectedLabelFeature,
            selectedBreakdownFeature, inferences) ||
            this.hasAttributions_(attributions);
        },

        shouldShowFeaturePerfCharts_: function(
          selectedLabelFeature,
          selectedBreakdownFeature,
          inferences
        ) {
          return (
            selectedLabelFeature != '' &&
            selectedBreakdownFeature != '' &&
            inferences != null
          );
        },

        shouldShowFeaturePerfAttributionCharts_: function(
            selectedLabelFeature, selectedBreakdownFeature, inferences,
            attributions) {
          return this.shouldShowFeaturePerfCharts_(selectedLabelFeature,
            selectedBreakdownFeature, inferences) ||
            this.hasAttributions_(attributions);
        },

        shouldShowCostRatio_: function(
          selectedLabelFeature,
          modelType,
          multiClass
        ) {
          return (
            selectedLabelFeature != '' &&
            this.isBinaryClassification_(modelType, multiClass)
          );
        },

        shouldShowAttributionMetrics_: function(meanAttributions) {
          return meanAttributions != null && meanAttributions.length > 0;
        },

        arePartialDependencePlotsEnabled_: function(
          selectedExampleAndInference,
          modelName,
          inferenceAddress
        ) {
          return (
            this.hasSelected(selectedExampleAndInference) &&
            this.areExamplesEditable_(modelName, inferenceAddress)
          );
        },

        hasSelected: function(selectedExampleAndInference) {
          return selectedExampleAndInference != null;
        },

        getFeatureList_: function(stats) {
          // Do not also threshold settings by the results of the inference as
          // they aren't real data features.
          const features = Object.keys(stats)
            .filter((feature) => !this.isComputedKeyStr_(feature))
            .sort();
          // Add a blank feature to be used for clearing the selected feature.
          features.push('');
          return features;
        },

        strStartsWith_: function(inStr, prefixStr) {
          return inStr.lastIndexOf(prefixStr, 0) == 0;
        },

        getModelName_: function(modelNumber) {
          return this.parsedModelNames[modelNumber];
        },

        strWithModelName_: function(inStr, modelNumber) {
          if (this.numModels > 1) {
            return inStr + ' ' + this.getModelName_(modelNumber);
          } else {
            return inStr;
          }
        },

        // Add model name to the provided string if multiple models have
        // attributions provided.
        attributionStrWithModelName_: function(inStr, modelNumber) {
          if (this.hasMultipleModelAttributions_(this.attributions)) {
            return inStr + ' ' + this.getModelName_(modelNumber);
          } else {
            return inStr;
          }
        },

        updateNumberOfModels: function() {
          this._setNumModels(this.modelName.split(',').length);
          // Initialize default overall thresholds
          this.selectedLabelFeature = '';
          this.selectedBreakdownFeature = '';
          this.selectedSecondBreakdownFeature = '';
          const overallThresholds = [];
          for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
            overallThresholds.push({threshold: 0.5});
          }
          this.set('overallThresholds', overallThresholds);

          // If inference can be performed automatically at this point, due to
          // examples already being set, and now the model being set, then
          // cause inference to run.
          if (
            !this.shouldDisableInferButton_(
              this.examplesAndInferences,
              this.modelName,
              this.inferenceAddress,
              this.updatedExample
            )
          ) {
            this.inferClicked_();
          }
        },

        isComputedKeyStr_: function(feature) {
          return (
            this.strStartsWith_(feature, inferenceValueStr) ||
            this.strStartsWith_(feature, inferenceLabelStr) ||
            this.strStartsWith_(feature, inferenceCorrectStr) ||
            this.strStartsWith_(feature, inferenceErrorStr) ||
            this.strStartsWith_(feature, inferenceScoreStr) ||
            this.strStartsWith_(feature, inferenceAbsErrorStr) ||
            this.strStartsWith_(feature, inferenceSquaredErrorStr) ||
            feature == exampleIdKey ||
            this.facetDistFeatureNames.indexOf(feature) != -1
          );
        },

        isAttributionKeyStr_: function(feature) {
          return this.strStartsWith_(feature, attributionPrefix);
        },

        /**
         * Get the key to which this example belongs when the dataset is sliced by the given feature(s).
         */
        getSliceKey_: function(example, feature1, feature2) {
          const bucketEdges = this.featureBucketEdges_;
          function maybeAggregate(feature) {
            if (feature && example[feature] === undefined) {
              return '?';
            }
            const edges = bucketEdges[feature];
            if (edges) {
              for (let i = 1; i < edges.length; i++) {
                if (
                  example[feature] < edges[i] ||
                  (example[feature] === edges[i] && i === edges.length - 1)
                ) {
                  const right = i < edges.length - 1 ? ')' : ']';
                  return '[' + edges[i - 1] + ', ' + edges[i] + right;
                }
              }
            }
            return example[feature];
          }
          return this.createCombinedValueString_(
            maybeAggregate(feature1),
            maybeAggregate(feature2)
          );
        },

        /**
         * Creates a list of all feature values of the selected breakdown feature
         * or feature crosses if two breakdown features are selected, and gets
         * inference stats per breakdown.
         */
        breakdownFeatureSelected_: function() {
          // When features to slice by change, set optimization strategy
          // back to custom (default).
          this.resetOptimizationSelected_();
          if (this.selectedBreakdownFeature == '') {
            this.selectedSecondBreakdownFeature = '';
          }
          this.calculateBucketEdges_(
            this.selectedBreakdownFeature,
            this.numPrimaryBuckets
          );
          this.calculateBucketEdges_(
            this.selectedSecondBreakdownFeature,
            this.numSecondaryBuckets
          );

          const thresholds = [];
          const thresholdsIndexMap = {};
          this.visdata.forEach((item) => {
            const key1 = this.getSliceKey_(item, this.selectedBreakdownFeature);
            const key2 = this.getSliceKey_(
              item,
              this.selectedSecondBreakdownFeature
            );
            const key = this.createCombinedValueString_(key1, key2);
            if (!(key in thresholdsIndexMap)) {
              thresholds.push({
                value: key1,
                value2: key2,
                threshold: deepClone(this.overallThresholds),
                opened: false,
              });
              thresholdsIndexMap[key] = thresholds.length - 1;
            }
          });
          this.set('featureValueThresholds', thresholds);
          this.refreshInferences_(false);
        },

        featureValueThresholdsChanged_: function(featureValueThresholds) {
          const map = {};
          for (let i = 0; i < featureValueThresholds.length; i++) {
            const key = this.createCombinedValueString_(
              featureValueThresholds[i].value,
              featureValueThresholds[i].value2
            );
            map[key] = i;
          }
          this.featureValueThresholdsIndexMap = map;
        },

        labelFeatureSelected_: function(feature) {
          // When the true label feature is selected, update inference stats.
          requestAnimationFrame(() => {
            this.updateInferenceStats_(true);
            this.refreshDive_();
          });
        },

        sideTabSelectedChanged_: function(tab) {
          if (tab == 1) {
            requestAnimationFrame(() => {
              this.updateInferenceStats_(true);
            });
          } else if (tab == 2) {
            // Force redraw of facets overview tables to ensure proper sizing.
            const tables = this.$.overview.querySelectorAll(
              'facets-overview-table'
            );
            for (let i = 0; i < tables.length; i++) {
              tables[i]._handleResize();
            }
          }
        },

        /**
         * Updates inference statistics, including breakdown stats if breakdown
         * features are selected, and updates visuals for those performance
         * stats.
         */
        updateInferenceStats_: function(regenInferenceStats) {
          // In the case user changes the number of models without refreshing
          // the page:
          // - The code may enter updateInferenceStats before
          // examplesAndInferences is updated for the correct number of models
          // - This may get called without regenInferenceStats, but
          // inferenceStats still contains the results for the old number of
          // models
          if (
            !this.inferenceStats_ ||
            !this.visdata ||
            this.selectedLabelFeature == '' ||
            this.examplesAndInferences.length == 0 ||
            this.examplesAndInferences[0].inferences == null ||
            this.examplesAndInferences[0].inferences[0].length !=
              this.numModels ||
            (this.inferenceStats_.length != this.numModels &&
              !regenInferenceStats)
          ) {
            return;
          }
          if (regenInferenceStats) {
            const inferenceStatsArray = [];
            let regressionEntries = [];
            for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
              let inferenceStats = {};
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                // For binary classifiers, update the confusion matrices values
                // for all possible classification thresholds.
                inferenceStats.thresholds = [];
                for (let i = 0; i < 101; i++) {
                  inferenceStats.thresholds.push({TP: 0, FP: 0, FN: 0, TN: 0});
                }
                inferenceStats.faceted = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    if (!inferenceStats.faceted[facetKey]) {
                      inferenceStats.faceted[facetKey] = {thresholds: []};
                      for (let i = 0; i < 101; i++) {
                        inferenceStats.faceted[facetKey].thresholds.push({
                          TP: 0,
                          FP: 0,
                          FN: 0,
                          TN: 0,
                        });
                      }
                    }
                    facetedStats = inferenceStats.faceted[facetKey].thresholds;
                  }
                  const nonZeroClassification = this.getClassificationBestNonZero(
                    i,
                    modelInd
                  );
                  let thresh = 0;
                  for (; thresh <= 100; thresh++) {
                    if (thresh > nonZeroClassification.score * 100) {
                      break;
                    }
                    if (
                      +item[this.selectedLabelFeature] ==
                      +nonZeroClassification.label
                    ) {
                      inferenceStats.thresholds[thresh]['TP'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['TP'] += 1;
                      }
                    } else {
                      inferenceStats.thresholds[thresh]['FP'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['FP'] += 1;
                      }
                    }
                  }
                  for (; thresh <= 100; thresh++) {
                    if (
                      item[this.selectedLabelFeature] == null ||
                      +item[this.selectedLabelFeature] == 0
                    ) {
                      inferenceStats.thresholds[thresh]['TN'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['TN'] += 1;
                      }
                    } else {
                      inferenceStats.thresholds[thresh]['FN'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['FN'] += 1;
                      }
                    }
                  }
                }
                // For binary classification, no need to specify all possible
                // labels for the confusion matrices as the data contains both
                // classes.
                this.allConfMatrixLabels = [];

                this.calcThresholdStats(inferenceStats.thresholds);
                for (let key in inferenceStats.faceted) {
                  if (inferenceStats.faceted.hasOwnProperty(key)) {
                    this.calcThresholdStats(inferenceStats.faceted[key].thresholds);
                  }
                }
              } else if (this.isMultiClass_(this.modelType, this.multiClass)) {
                // For multi-class classifiers, update the confusion matrices.
                inferenceStats.results = {};
                inferenceStats.faceted = {};
                const allLabels = new Set();
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    if (!inferenceStats.faceted[facetKey]) {
                      inferenceStats.faceted[facetKey] = {results: {}};
                    }
                    facetedStats = inferenceStats.faceted[facetKey].results;
                  }
                  let statsActual =
                    inferenceStats.results[item[this.selectedLabelFeature]];
                  if (!statsActual) {
                    inferenceStats.results[
                      item[this.selectedLabelFeature]
                    ] = {};
                    statsActual =
                      inferenceStats.results[item[this.selectedLabelFeature]];
                  }
                  const modelInferenceValueStr = this.strWithModelName_(
                    inferenceValueStr,
                    modelInd
                  );
                  let count = statsActual[item[modelInferenceValueStr]];
                  allLabels.add(String(item[modelInferenceValueStr]));
                  allLabels.add(String(item[this.selectedLabelFeature]));
                  if (count == null) {
                    statsActual[item[modelInferenceValueStr]] = 1;
                  } else {
                    statsActual[item[modelInferenceValueStr]] += 1;
                  }
                  if (facetedStats) {
                    let statsActual =
                      facetedStats[item[this.selectedLabelFeature]];
                    if (!statsActual) {
                      facetedStats[item[this.selectedLabelFeature]] = {};
                      statsActual =
                        facetedStats[item[this.selectedLabelFeature]];
                    }
                    let count = statsActual[item[modelInferenceValueStr]];
                    if (count == null) {
                      statsActual[item[modelInferenceValueStr]] = 1;
                    } else {
                      statsActual[item[modelInferenceValueStr]] += 1;
                    }
                  }
                }
                this.allConfMatrixLabels = Array.from(allLabels.values());
                // Compute confusion data for perf curves
                const thresholds = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.examplesAndInferences[i];
                  const trueLabel = this.visdata[i][
                    this.selectedLabelFeature
                  ].toString();
                  const scores =
                    item.inferences[item.inferences.length - 1][modelInd];
                  const slice =
                    this.selectedBreakdownFeature != ''
                      ? this.getSliceKey_(
                          this.visdata[i],
                          this.selectedBreakdownFeature,
                          this.selectedSecondBreakdownFeature
                        )
                      : '';
                  if (!(slice in thresholds)) {
                    thresholds[slice] = {};
                  }
                  for (let k = 0; k < scores.length; k++) {
                    const label = scores[k].label;
                    if (!(label in thresholds[slice])) {
                      thresholds[slice][label] = [];
                      for (let thresh = 0; thresh <= 100; thresh++) {
                        thresholds[slice][label].push({
                          TP: 0,
                          FP: 0,
                          FN: 0,
                          TN: 0,
                        });
                      }
                    }
                    const score = scores[k].score * 100;
                    let result = '';
                    for (let thresh = 0; thresh <= 100; thresh++) {
                      if (label === trueLabel) {
                        result = score > thresh ? 'TP' : 'FN';
                      } else {
                        result = score > thresh ? 'FP' : 'TN';
                      }
                      thresholds[slice][label][thresh][result] += 1;
                    }
                  }
                }
                Object.values(thresholds).forEach((t) =>
                  Object.values(t).forEach(this.calcThresholdStats)
                );
                inferenceStats.allThresholds = thresholds;
              } else {
                // For regression models, calculate inference error.
                inferenceStats.results = {errors: []};
                inferenceStats.faceted = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    facetedStats = inferenceStats.faceted[facetKey];
                    if (!facetedStats) {
                      inferenceStats.faceted[facetKey] = {results: {errors: []}};
                      facetedStats = inferenceStats.faceted[facetKey];
                    }
                  }
                  const inferenceError =
                    item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                    item[this.selectedLabelFeature];
                  inferenceStats.results.errors.push(inferenceError);
                  if (facetedStats) {
                    facetedStats.results.errors.push(inferenceError);
                  }
                }
                regressionEntries.push(
                  this.fillInRegressionStats(
                    inferenceStats.results,
                    this.formatChartKey(
                      'All datapoints',
                      modelInd,
                      this.numModels
                    )
                  )
                );
                for (let key in inferenceStats.faceted) {
                  regressionEntries.push(
                    this.fillInRegressionStats(
                      inferenceStats.faceted[key].results,
                      this.formatChartKey(key, modelInd, this.numModels)
                    )
                  );
                }
              }
              inferenceStatsArray.push(inferenceStats);
            }

            // Calculate global attribution stats for entire dataset and also
            // for each facet of the dataset, if dataset has been sliced.

            // For each model, store a list of all attributions for each
            // feature, in order to do the averaging. Also do the same
            // for each facet of the dataset if sliced.
            const combinedAttributions = [
              ...new Array(this.numModels)].map(() => {return {};});
            const facetedAttributions = {};
            this.allAttributions_.forEach((attribution, i) => {
              for (let model = 0; model < attribution.length; model++) {
                if (attribution[model] == null) {
                  continue;
                }
                let facetedAttrEntry = null;
                if (this.selectedBreakdownFeature != '') {
                  const facetKey = this.getSliceKey_(
                    this.visdata[i],
                    this.selectedBreakdownFeature,
                    this.selectedSecondBreakdownFeature
                  );
                  if (!facetedAttributions[facetKey]) {
                    facetedAttributions[facetKey] = [
                      ...new Array(this.numModels)].map(() => {return {};});
                  }
                  facetedAttrEntry = facetedAttributions[facetKey];
                }
                const keys = Object.keys(attribution[model]);
                keys.forEach(key => {
                  if (!(key in combinedAttributions[model])) {
                    combinedAttributions[model][key] = [];
                  }
                  combinedAttributions[model][key] = combinedAttributions[
                    model][key].concat(attribution[model][key]);
                  if (facetedAttrEntry != null) {
                    if (!(key in facetedAttrEntry[model])) {
                      facetedAttrEntry[model][key] = [];
                    }
                    facetedAttrEntry[model][key] = facetedAttrEntry[
                      model][key].concat(attribution[model][key]);
                  }
                });
              }
            });

            // Get the mean of each of the lists of attributions collected
            // in the previous loop. Sort each list of features from highest
            // to lowest mean attribution.
            const meanAttributions = [
              ...new Array(this.numModels)].map(() => {return [];});
            const facetedMeanAttributions = {};
            for (let model = 0; model < combinedAttributions.length; model++) {
              const keys = Object.keys(combinedAttributions[model]);
              keys.forEach(key => {
                const attrs = combinedAttributions[model][key];
                const mean = attrs.reduce((a, b) => a + b) / attrs.length;
                meanAttributions[model].push({key, mean});
              });
              meanAttributions[model].sort((a, b) => b.mean - a.mean);
            }
            const facetedKeys = Object.keys(facetedAttributions);
            if (facetedKeys.length > 0) {
              facetedKeys.forEach(key => {
                facetedMeanAttributions[key] = [
                  ...new Array(this.numModels)].map(() => {return [];});
                const facet = facetedAttributions[key];
                for (let model = 0; model < facet.length; model++) {
                  const features = Object.keys(facet[model]);
                  features.forEach(feature => {
                    const attrs = facet[model][feature];
                    const mean = attrs.reduce((a, b) => a + b) / attrs.length;
                    facetedMeanAttributions[key][model].push(
                      {key: feature, mean});
                  });
                  facetedMeanAttributions[key][model].sort(
                    (a, b) => b.mean - a.mean);
                }
              });
            }
            this.meanAttributions_ = meanAttributions;
            this.facetedMeanAttributions_ = facetedMeanAttributions;

            regressionEntries = this.sortRegressionEntries(regressionEntries);
            this.regressionEntries_ = [];
            this.regressionEntries_ = regressionEntries;
            this.inferenceStats_ = inferenceStatsArray;
          }

          // Assigning to tempArray to force polymer to update the array.
          // Polymer does not recognize updates to elements within the array
          const tempArray = this.featureValueThresholds;
          this.featureValueThresholds = [];
          this.featureValueThresholds = this.sortFeatureValues(tempArray);

          // ROC and PR curves for the binary case
          if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
            for (let i = 0; i < this.featureValueThresholds.length; i++) {
              const plotStats = [];
              const plotThresholds = [];
              const modelThresholds = this.featureValueThresholds[i].threshold;
              for (
                let modelInd = 0;
                modelInd < modelThresholds.length;
                modelInd++
              ) {
                const inferenceStats = this.inferenceStats_[modelInd];
                const key = this.createCombinedValueString_(
                  this.featureValueThresholds[i].value,
                  this.featureValueThresholds[i].value2
                );
                plotStats.push(inferenceStats.faceted[key]);
                plotThresholds.push(modelThresholds[modelInd].threshold);
              }
              this.plotChart(
                this.$$('#' + this.getRocChartId(i)),
                plotStats,
                plotThresholds,
                regenInferenceStats,
                true
              );
              this.plotChart(
                this.$$('#' + this.getPrChartId(i)),
                plotStats,
                plotThresholds,
                regenInferenceStats,
                false
              );
            }
            const plotStats = [];
            const plotThresholds = [];
            for (
              let modelInd = 0;
              modelInd < this.inferenceStats_.length;
              modelInd++
            ) {
              plotStats.push(this.inferenceStats_[modelInd]);
              plotThresholds.push(this.overallThresholds[modelInd].threshold);
            }
            this.plotChart(
              this.$$('#rocchart'),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              true
            );
            this.plotChart(
              this.$$('#prchart'),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              false
            );
          }
          // ROC and PR curves for the multi-class case
          else if (this.isMultiClass_(this.modelType, this.multiClass)) {
            const isSliced = this.featureValueThresholds.length > 0;
            const slices = isSliced
              ? this.featureValueThresholds.map((slice) =>
                  this.createCombinedValueString_(slice.value, slice.value2)
                )
              : [''];
            for (let sliceInd = 0; sliceInd < slices.length; sliceInd++) {
              const slice = slices[sliceInd];
              for (
                let labelInd = 0;
                labelInd < this.allConfMatrixLabels.length;
                labelInd++
              ) {
                const label = this.allConfMatrixLabels[labelInd];
                const plotStats = [];
                const plotThresholds = [];
                const thresholds = isSliced
                  ? this.featureValueThresholds[sliceInd].threshold
                  : this.overallThresholds;
                for (
                  let modelInd = 0;
                  modelInd < this.inferenceStats_.length;
                  modelInd++
                ) {
                  plotStats.push({
                    thresholds: this.inferenceStats_[
                      modelInd].allThresholds[slice][label]
                  });
                  plotThresholds.push(thresholds[modelInd].threshold);
                }
                this.plotChart(
                  this.$$(
                    '#' +
                      this.getRocChartLabelId(
                        labelInd,
                        isSliced ? sliceInd : ''
                      )
                  ),
                  plotStats,
                  plotThresholds,
                  regenInferenceStats,
                  true
                );
                this.plotChart(
                  this.$$(
                    '#' +
                      this.getPrChartLabelId(labelInd, isSliced ? sliceInd : '')
                  ),
                  plotStats,
                  plotThresholds,
                  regenInferenceStats,
                  false
                );
              }
            }
          }
          this.updateCorrectness_();
        },

        sortFeatureValues: function(values) {
          const inferenceStats = this.inferenceStats_[0];
          values = values.filter((a) => {
            if (this.isRegression_(this.modelType)) {
              return this.getRegressionCount(inferenceStats, a) > 0;
            } else if (
              this.isBinaryClassification_(this.modelType, this.multiClass)
            ) {
              return this.getBinaryClassificationCount(inferenceStats, a) > 0;
            } else {
              return (
                this.getMulticlassClassificationCount(inferenceStats, a) > 0
              );
            }
          });
          return values.sort((a, b) => {
            if (this.selectedFeatureSort == 'Count') {
              if (this.isRegression_(this.modelType)) {
                return (
                  this.getRegressionCount(inferenceStats, b) -
                  this.getRegressionCount(inferenceStats, a)
                );
              } else if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                return (
                  this.getBinaryClassificationCount(inferenceStats, b) -
                  this.getBinaryClassificationCount(inferenceStats, a)
                );
              } else {
                return (
                  this.getMulticlassClassificationCount(inferenceStats, b) -
                  this.getMulticlassClassificationCount(inferenceStats, a)
                );
              }
            } else if (this.selectedFeatureSort == 'Alphabetical') {
              const aValue = this.getPrintableValue_(a);
              const bValue = this.getPrintableValue_(b);
              // Handle numeric intervals
              if (aValue[0] === '[' && bValue[0] === '[') {
                return (
                  Number.parseFloat(aValue.substring(1)) -
                  Number.parseFloat(bValue.substring(1))
                );
              }
              return aValue.localeCompare(bValue);
            } else if (this.selectedFeatureSort == 'Accuracy') {
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                return (
                  +this.getAccuracyModelIndex(
                    this.inferenceStats_,
                    b.threshold,
                    0,
                    b
                  ) -
                  +this.getAccuracyModelIndex(
                    this.inferenceStats_,
                    a.threshold,
                    0,
                    a
                  )
                );
              } else {
                return (
                  +this.getMultiClassAccuracyModelIndex(
                    this.inferenceStats_,
                    0,
                    b
                  ) -
                  +this.getMultiClassAccuracyModelIndex(
                    this.inferenceStats_,
                    0,
                    a
                  )
                );
              }
            } else if (this.selectedFeatureSort == 'False positives') {
              return (
                +this.getFPModelIndex(this.inferenceStats_, b.threshold, 0, b) -
                +this.getFPModelIndex(this.inferenceStats_, a.threshold, 0, a)
              );
            } else if (this.selectedFeatureSort == 'False negatives') {
              return (
                this.getFNModelIndex(+this.inferenceStats_, b.threshold, 0, b) -
                +this.getFNModelIndex(this.inferenceStats_, a.threshold, 0, a)
              );
            }
          });
        },

        sortRegressionEntries: function(regressionEntries) {
          return regressionEntries.sort((a, b) => {
            if (this.selectedFeatureSort == 'Count') {
              return b.count - a.count;
            } else if (this.selectedFeatureSort == 'Alphabetical') {
              // Handle numeric intervals
              if (a.name[0] === '[' && b.name[0] === '[') {
                return (
                  Number.parseFloat(a.name.substring(1)) -
                  Number.parseFloat(b.name.substring(1))
                );
              }
              return a.name.localeCompare(b.name);
            } else if (this.selectedFeatureSort == 'Mean error') {
              return b.meanError - a.meanError;
            } else if (this.selectedFeatureSort == 'Mean absolute error') {
              return b.meanAbsError - a.meanAbsError;
            } else if (this.selectedFeatureSort == 'Mean squared error') {
              return b.meanSquaredError - a.meanSquaredError;
            } else if (this.selectedFeatureSort == 'Median error') {
              return b.medianError - a.medianError;
            } else if (this.selectedFeatureSort == 'Median absolute error') {
              return b.medianAbsError - a.medianAbsError;
            } else if (this.selectedFeatureSort == 'Median squared error') {
              return b.medianSquaredError - a.medianSquaredError;
            }
          });
        },

        fillInRegressionStats: function(regressionStats, name) {
          // From initial regression stats having regression error per example,
          // calculate error statistics.
          function mean(data) {
            const sum = data.reduce((sum, value) => {
              return sum + value;
            }, 0);

            return sum / data.length;
          }
          function median(data) {
            if (data.length == 0) {
              return NaN;
            }
            const sortedData = data.sort((a, b) => a - b);
            const midIndex = sortedData.length / 2;
            if (sortedData.length == 1) {
              return sortedData[0];
            } else if (sortedData.length % 2 == 0) {
              return sortedData[midIndex];
            } else {
              return (
                (sortedData[Math.floor(midIndex)] +
                  sortedData[Math.ceil(midIndex)]) /
                2
              );
            }
          }

          const absErrors = regressionStats.errors.map((err) => Math.abs(err));
          const squaredErrors = regressionStats.errors.map((err) => err * err);

          return {
            name: name,
            meanError: mean(regressionStats.errors),
            meanAbsError: mean(absErrors),
            meanSquaredError: mean(squaredErrors),
            medianError: median(regressionStats.errors),
            medianAbsError: median(absErrors),
            medianSquaredError: median(squaredErrors),
            count: regressionStats.errors.length,
          };
        },

        /**
         * Plots a PR or ROC purve given data to plot.
         * thresholdstats and thresholds are arrays, indexed by model number
         */
        plotChart: function(
          chart,
          thresholdStats,
          thresholds,
          regenInferenceStats,
          isRoc
        ) {
          if (!thresholdStats || !thresholdStats[0] || !chart) {
            return;
          }
          const visibleCharts = [];
          const seriesColors = [];
          const xAxis = isRoc ? 'FPR' : 'TPR';
          const yAxis = isRoc ? 'TPR' : 'PPV';
          const xAxisLabel = isRoc ? 'FPR' : 'Recall';
          const yAxisLabel = isRoc ? 'TPR' : 'Precision';
          const projectionsForModels = []; // collected for AUC calculation
          for (let modelInd = 0; modelInd < thresholdStats.length; modelInd++) {
            let currentThresholdData = null;
            const data = thresholdStats[modelInd].thresholds
              .map((thresh, i) => {
                // This finds the furthest point on the line that is below the
                // current threshold
                if (i - thresholds[modelInd] * 100 < 0.5) {
                  currentThresholdData = {
                    step: thresh[xAxis],
                    scalar: thresh[yAxis],
                    threshold: i / 100,
                  };
                }
                return {
                  step: thresh[xAxis],
                  scalar: thresh[yAxis],
                  threshold: i / 100,
                };
              })
              .reverse();
            projectionsForModels.push(data);
            chart.setSeriesData(
              this.strWithModelName_('Threshold set', modelInd),
              [currentThresholdData]
            );
            if (regenInferenceStats) {
              chart.setSeriesData(
                this.strWithModelName_('ROC', modelInd),
                data
              );
              visibleCharts.push(this.strWithModelName_('ROC', modelInd));
              visibleCharts.push(
                this.strWithModelName_('Threshold set', modelInd)
              );
              seriesColors.push(this.rocCurveLineColors[modelInd]);
              seriesColors.push(this.rocCurveColors[modelInd]);
            }
          }
          if (regenInferenceStats) {
            const valueFormatter = d3.format('.2f');
            chart.xAxisFormatter = d3.format('.2f');
            const percentageFormatter = d3.format(',.1');
            const tooltipColumns = [
              {
                title: 'Threshold',
                evaluate: function(d) {
                  return valueFormatter(d.datum.threshold);
                },
              },
              {
                title: yAxisLabel,
                evaluate: function(d) {
                  return isRoc
                    ? percentageFormatter(d.datum.scalar)
                    : valueFormatter(d.datum.scalar);
                },
              },
              {
                title: xAxisLabel,
                evaluate: function(d) {
                  return isRoc
                    ? percentageFormatter(d.datum.step)
                    : valueFormatter(d.datum.step);
                },
              },
            ];
            // When more than one model is available, make tooltip show an extra
            // column for model id
            if (thresholdStats.length > 1) {
              tooltipColumns.push({
                title: 'Model',
                evaluate: function(d) {
                  const modelId = d.dataset.metadata().name.split(' ');
                  return modelId[modelId.length - 1];
                },
              });
            }
            chart.tooltipColumns = tooltipColumns;
            chart.colorScale = new Plottable.Scales.Color().range(seriesColors);
            chart.colorScale.domain(visibleCharts);
            chart.setVisibleSeries(visibleCharts);
          }

          // Update AUC values
          if (projectionsForModels.length > 0) {
            this.updateAucs_(chart.id, projectionsForModels);
          }
        },

        /*
         * Sets updated value for `this.aucs_``
         * This assigns the property as a whole so Polymer notices
         * and updates the DOM (which is why it's copying existing values).
         */
        updateAucs_(chartId, projectionsForModels) {
          const updatedAucs = {};
          Object.keys(this.aucs_ || {}).forEach(aucKey => {
            updatedAucs[aucKey] = this.aucs_[aucKey];
          });
          projectionsForModels.forEach((projectionsForModel, modelIndex) => {
            const aucKey = [chartId, modelIndex].join(':');
            updatedAucs[aucKey] = this.calculateAreaUnderCurve(projectionsForModel);
          });
          this.aucs_ = updatedAucs;
          return;
        },

        /**
         * Takes a list of [{step, scalar, threshold}] at each discrete threshold value,
         * and returns the area under the curve.
         */
        calculateAreaUnderCurve(chartXys) {
          let auc = 0;
          let last = chartXys[0];
          for (let i = 1; i < chartXys.length; i++) {
            let width = (chartXys[i].step - last.step);
            let height = (chartXys[i].scalar - last.scalar);
            let rect = (width * Math.min(chartXys[i].scalar, last.scalar))
            let triangle = (width * height) / 2;

            auc += (rect + triangle);
            last = chartXys[i];
          }
          return auc;
        },

        getRocChartTitleOverall: function(aucs_) {
          return this.formattedChartTitleWithAucs_('ROC curve', 'rocchart');
        },

        getRocChartTitleForSlice: function(aucs_, index) {
          const chartId = this.getRocChartId(index);
          return this.formattedChartTitleWithAucs_('ROC curve', chartId);
        },

        getRocChartTitleForLabel: function(aucs_, labelIndex, sliceIndexOrEmpty) {
          const chartId = this.getRocChartLabelId(labelIndex, sliceIndexOrEmpty);
          const label = this.getLabel(labelIndex);
          return this.formattedChartTitleWithAucs_(`ROC curve for ${label}`, chartId);
        },

        getPrChartTitleOverall: function(aucs_) {
          return this.formattedChartTitleWithAucs_('PR curve', 'prchart');
        },

        getPrChartTitleForSlice: function(aucs_, index) {
          const chartId = this.getPrChartId(index);
          return this.formattedChartTitleWithAucs_('PR curve', chartId);
        },

        getPrChartTitleForLabel(aucs_, labelIndex, sliceIndexOrEmpty) {
          const chartId = this.getPrChartLabelId(labelIndex, sliceIndexOrEmpty);
          const label = this.getLabel(labelIndex);
          return this.formattedChartTitleWithAucs_(`PR curve for ${label}`, chartId);
        },

        /* Reads precomputed value and formats it for the UI.
         * AUC values are computed in `plotChart`, and the string building
         * complexity here is for when a chart has more than one series
         * (eg, when comparing models), and so more than one AUC value.
         */
        formattedChartTitleWithAucs_(title, chartId) {
          if (!this.aucs_ || this.numModels === 0) {
            return title;
          }

          if (this.numModels === 1) {
            let valueText = this.formattedAucForModel_(chartId, 0);
            return `${title} (AUC: ${valueText})`;
          }

          // multiple models in the title
          // example: `PR Curve (AUCs: 0.82, 0.64)`
          let valueTexts = [];
          for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
            valueTexts.push(this.formattedAucForModel_(chartId, modelInd));
          }
          return `${title} (AUCs: ${valueTexts.join(', ')})`;
        },

        formattedAucForModel_(chartId, modelIndex) {
          const aucKey = [chartId, modelIndex].join(':');
          const aucValue = this.aucs_[aucKey];
          return (aucValue && aucValue.toFixed)
            ? aucValue.toFixed(2)
            : 0;
        },

        describeRocChart() {
          return `
            A receiver operating characteristic (ROC) curve plots the true
            positive rate (TPR) against the false positive rate (FPR) at
            various classification thresholds.
          `;
        },

        describeRocAuc() {
          return `
            Area under the curve (AUC) summarizes model performance across
            all thresholds, and ROC-AUC represents the probability that a
            random positive example will have a higher score than a random
            negative example.
          `;
        },

        describePrChart() {
          return `
            A precision-recall (PR) curve plots precision against recall at
            various classification thresholds.
          `;
        },

        describePrAuc() {
          return `
            Area under the curve (AUC) summarizes performance across all
            thresholds, and PR-AUC typically corresponds to the average
            precision.
          `;
        },

        /**
         * Calculates TPR, FPR, and PPV given binary confusion matrix counts.
         */
        calcThresholdStats: function(stats) {
          for (let i = 0; i < stats.length; i++) {
            if (stats[i]['TP'] + stats[i]['FN'] > 0) {
              stats[i]['TPR'] =
                stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FN']);
            } else {
              stats[i]['TPR'] = 0;
            }
            if (stats[i]['FP'] + stats[i]['TN'] > 0) {
              stats[i]['FPR'] =
                stats[i]['FP'] / (stats[i]['FP'] + stats[i]['TN']);
            } else {
              stats[i]['FPR'] = 0;
            }
            if (stats[i]['TP'] + stats[i]['FP'] > 0) {
              stats[i]['PPV'] =
                stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FP']);
            } else {
              stats[i]['PPV'] = 0;
            }
          }
        },

        /**
         * Runs the appropriate threshold optimizer.
         */
        optimizationSelectedChanged_: function(selection) {
          if (selection == 'custom') {
            return;
          } else if (selection == 'unaware') {
            this.optimizeThresholdClicked_();
          } else if (selection == 'group') {
            this.optimizeFacetedThresholdsClicked_();
          } else if (selection == 'demoparity') {
            this.demoParityClicked_();
          } else if (selection == 'equalacc') {
            this.equalAccClicked_();
          } else if (selection == 'equalopp') {
            this.equalOppoClicked_();
          }
          this.updateInferenceStats_(true);
        },

        costRatioChanged_: function() {
          // When cost ratio changes, set optimization strategy
          // back to custom (default).
          this.resetOptimizationSelected_();
        },

        resetOptimizationSelected_: function() {
          const button = this.$$('#customthresh');
          if (button != null) {
            button.click();
          }
        },

        optimizeThresholdClicked_: function() {
          // Find the optimal threshold for all examples, then set all thresholds
          // to that value.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            const thresholdToSet = this.findOptimalThreshold_(
              this.inferenceStats_[modelInd].thresholds
            );
            this.set(
              'overallThresholds.' + modelInd + '.threshold',
              thresholdToSet
            );
            if (this.featureValueThresholds) {
              for (let i = 0; i < this.featureValueThresholds.length; i++) {
                const thresholdPath =
                  'featureValueThresholds.' +
                  i +
                  '.threshold.' +
                  modelInd +
                  '.threshold';
                this.set(thresholdPath, thresholdToSet);
              }
            }
          }
        },

        optimizeFacetedThresholdsClicked_: function() {
          // For each faceted set of examples, find the optimal threshold and
          // set it.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            const values = Object.keys(this.inferenceStats_[modelInd].faceted);
            for (let i = 0; i < values.length; i++) {
              const featureValue = values[i];
              const thresholdToSet = this.findOptimalThreshold_(
                this.inferenceStats_[modelInd].faceted[featureValue].thresholds
              );
              this.set(
                'featureValueThresholds.' +
                  i +
                  '.threshold.' +
                  modelInd +
                  '.threshold',
                thresholdToSet
              );
            }
          }
        },

        /**
         * Returns an optimal threshold from all classification thresholds.
         */
        findOptimalThreshold_: function(thresholds) {
          let minCost = Number.POSITIVE_INFINITY;
          let bestThreshold = 0;
          for (let i = 0; i < thresholds.length; i++) {
            const cost = this.getCost(thresholds[i]);
            if (cost <= minCost) {
              minCost = cost;
              bestThreshold = i;
            }
          }
          return bestThreshold / 100;
        },

        equalOppoClicked_: function() {
          // Find the optimal thresholds while maintaining equal opportunity.
          const measure = (stats) => stats['TP'] / (stats['TP'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        equalAccClicked_: function() {
          // Find the optimal thresholds while maintaining equal accuracy.
          const measure = (stats) =>
            (stats['TP'] + stats['TN']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        demoParityClicked_: function() {
          // Find the optimal thresholds while maintaining demographic parity.
          const measure = (stats) =>
            (stats['TP'] + stats['FP']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        getBestThresholdsByFairnessMeasure_: function(fairnessCalculator) {
          // For all thresholds for first facet:
          //   For all other facets:
          //     Find threshold with closest fairness measure of first facet at
          //     current threshold
          //   Calculate cost for these threshold settings settings across the
          //   facets, and save if the lowest.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            let minCost = Number.POSITIVE_INFINITY;
            let bestThresholds = null;
            const modelStats = this.inferenceStats_[modelInd];
            const values = Object.keys(modelStats.faceted);
            const firstFacet = modelStats.faceted[values[0]].thresholds;
            for (let i = 0; i < firstFacet.length; i++) {
              const firstFacetMeasure = fairnessCalculator(firstFacet[i]);
              const facetThresholds = [i];
              let cost = this.getCost(firstFacet[i]);
              for (let facetIdx = 1; facetIdx < values.length; facetIdx++) {
                const currentFacet =
                  modelStats.faceted[values[facetIdx]].thresholds;
                const currentFacetThreshold = this.thresholdClosestToMeasure(
                  currentFacet,
                  firstFacetMeasure,
                  fairnessCalculator
                );
                facetThresholds.push(currentFacetThreshold);
                cost += this.getCost(currentFacet[currentFacetThreshold]);
              }
              if (cost <= minCost) {
                minCost = cost;
                bestThresholds = facetThresholds;
              }
            }

            // Set all thresholds to the setting with the lowest cost from the
            // above search.
            for (let vIdx = 0; vIdx < values.length; vIdx++) {
              const thresholdsIdx = this.featureValueThresholdsIndexMap[
                values[vIdx]
              ];
              this.set(
                'featureValueThresholds.' +
                  thresholdsIdx +
                  '.threshold.' +
                  modelInd +
                  '.threshold',
                bestThresholds[vIdx] / 100
              );
            }
          }
        },

        /**
         * Returns the cost of a classification threshold given the incorrect
         * inferences and the ratio of cost of false positives vs false negatives.
         */
        getCost: function(entries) {
          return entries['FP'] * this.incorrectPredCostRatio + entries['FN'];
        },

        /**
         * Helper function for finiding best thresholds with fairness measures.
         */
        thresholdClosestToMeasure: function(
          currentFacet,
          firstFacetMeasure,
          fairnessCalculator
        ) {
          let minDistance = Number.POSITIVE_INFINITY;
          let thresholdToReturn = 0;
          for (let i = 0; i < currentFacet.length; i++) {
            const measure = fairnessCalculator(currentFacet[i]);
            const curDistance = Math.abs(measure - firstFacetMeasure);
            if (curDistance <= minDistance) {
              thresholdToReturn = i;
              minDistance = curDistance;
            }
          }
          return thresholdToReturn;
        },

        /**
         * Finds the first inference label in the score-sorted list that is
         * non-zero.
         */
        getClassificationBestNonZero: function(index, modelIndex) {
          let indexForNonZeroLabel = 0;
          const inferenceIndex =
            this.examplesAndInferences[index].inferences.length - 1;
          for (
            let i = 0;
            i <
            this.examplesAndInferences[index].inferences[inferenceIndex][
              modelIndex
            ].length;
            i++
          ) {
            if (
              +this.examplesAndInferences[index].inferences[inferenceIndex][
                modelIndex
              ][i].label !== 0
            ) {
              indexForNonZeroLabel = i;
              break;
            }
          }
          return this.examplesAndInferences[index].inferences[inferenceIndex][
            modelIndex
          ][indexForNonZeroLabel];
        },

        /**
         * Gets confusion counts for a single model index modelInd
         */
        getConfusionCountsModelIndex: function(
          inferenceStats,
          thresholds,
          modelInd,
          item
        ) {
          // During updates inferenceStats and overallThresholds may get out of
          // sync, this if protects against indexing them before final state
          if (
            this.overallThresholds.length != this.numModels ||
            this.inferenceStats_.length != this.numModels
          ) {
            return {};
          } else {
            return this.getConfusionCounts(
              this.inferenceStats_[modelInd],
              thresholds[modelInd].threshold,
              item
            );
          }
        },

        /**
         * Returns the total number of entries in a confusion matrix.
         */
        getTotalEntriesInConfCounts: function(counts) {
          if (counts == null) {
            return 0;
          }
          let total = 0;
          const outerKeys = Object.keys(counts);
          for (let i = 0; i < outerKeys.length; i++) {
            const inner = counts[outerKeys[i]];
            const innerKeys = Object.keys(inner);
            for (let j = 0; j < innerKeys.length; j++) {
              total += inner[innerKeys[j]];
            }
          }
          return total;
        },

        /**
         * Returns the false positive percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getFPModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return null;
          }
          const val = confCounts['No']['Yes'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the false negative percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getFNModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const val = confCounts['Yes']['No'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the accuracy percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getAccuracyModelIndex: function(
          inferenceStats,
          thresholds,
          modelInd,
          item
        ) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const val = confCounts['Yes']['Yes'] + confCounts['No']['No'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the F1 score for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getF1ModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const formatter = d3.format(',.2f');
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const truePositives = confCounts['Yes']['Yes'];
          const falsePositives = confCounts['No']['Yes'];
          const falseNegatives = confCounts['Yes']['No'];
          if (truePositives == 0) {
            if (falsePositives != 0 || falseNegatives != 0) {
              return formatter(0);
            } else {
              return formatter(1);
            }
          }
          const precision = truePositives / (truePositives + falsePositives);
          const recall = truePositives / (truePositives + falseNegatives);
          return formatter((2 * (precision * recall)) / (precision + recall));
        },

        /**
         * Returns the number of examples in a given facet.
         */
        getFeatureValueCount: function(inferenceStats, thresholds, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            0,
            item
          );
          return this.getTotalEntriesInConfCounts(confCounts);
        },

        /**
         * Returns the label of a confusion matrix for a given model index.
         * When only using 1 model, no label is needed.
         */
        getConfusionMatrixLabel: function(index, numModels) {
          if (numModels < 2) {
            return '';
          }
          return this.getModelName_(index);
        },

        /**
         * Returns the background color of a confusion matrix based on
         * model index.
         */
        getConfusionMatrixColor: function(index) {
          return this.confMatrixColors[index];
        },

        /**
         * Gets binary confusion matrix counts from inference results.
         */
        getConfusionCounts(inferenceStats, threshold, item) {
          let val = null;
          let val2 = null;
          if (item != null) {
            val = item.value;
            val2 = item.value2;
          }
          return {
            No: {
              No: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'TN',
                val,
                val2
              ),
              Yes: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'FP',
                val,
                val2
              ),
            },
            Yes: {
              No: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'FN',
                val,
                val2
              ),
              Yes: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'TP',
                val,
                val2
              ),
            },
          };
        },

        /**
         * Helper method for getConfusionCounts
         */
        getConfMatrixValue: function(
          inferenceStats,
          threshold,
          stat,
          featureValue1,
          featureValue2
        ) {
          const index = Math.floor(threshold * 100);
          if (!inferenceStats.thresholds) {
            return 0;
          }
          if (featureValue1 === null) {
            return inferenceStats.thresholds[index][stat];
          }
          const key = this.createCombinedValueString_(
            featureValue1,
            featureValue2
          );
          if (inferenceStats.faceted[key] == null) {
            return 0;
          }
          return inferenceStats.faceted[key].thresholds[index][stat];
        },

        /**
         * Gets multi-class confusion matrix from inference stats.
         */
        getMultiClassConfMatrix: function(inferenceStats, modelInd, facetItem) {
          if (inferenceStats.length == 0) {
            return {};
          } else if (facetItem == null) {
            return inferenceStats[modelInd].results;
          } else {
            const key = this.getPrintableValue_(facetItem);
            if (inferenceStats[modelInd].faceted[key] == null) {
              return {};
            }
            return inferenceStats[modelInd].faceted[key].results;
          }
        },

        /**
         * Returns the number of examples in a given facet from a
         * multi-class confusion matrix.
         */
        getMultiClassFeatureValueCount: function(inferenceStats, facetItem) {
          const confCounts = this.getMultiClassConfMatrix(
            inferenceStats,
            0,
            facetItem
          );
          return this.getTotalEntriesInConfCounts(confCounts);
        },

        /**
         * Returns the accuracy percentage for a given multi-class confusion
         * matrix from the threshold selected, model index, and facet to view.
         */
        getMultiClassAccuracyModelIndex: function(
          inferenceStats,
          modelInd,
          facetItem
        ) {
          const confCounts = this.getMultiClassConfMatrix(
            inferenceStats,
            modelInd,
            facetItem
          );
          if (confCounts == null) {
            return null;
          }
          let matches = 0;
          const outerKeys = Object.keys(confCounts);
          for (let i = 0; i < outerKeys.length; i++) {
            const inner = confCounts[outerKeys[i]];
            const innerKeys = Object.keys(inner);
            for (let j = 0; j < innerKeys.length; j++) {
              if (outerKeys[i] == innerKeys[j]) {
                matches += inner[innerKeys[j]];
              }
            }
          }
          return d3.format(',.1f')(
            (matches / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Gets a inference statistic from inference results.
         */
        getInferenceStat: function(
          inferenceStats,
          facetItem,
          getter,
          formatter
        ) {
          const stats = facetItem
            ? inferenceStats.faceted[this.getPrintableValue_(facetItem)]
            : inferenceStats;
          if (!stats) {
            return null;
          }
          const val = getter(stats);
          if (!formatter) {
            return val;
          } else {
            return formatter(val);
          }
        },

        getRegressionMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.results.mean,
            d3.format('.3f')
          );
        },

        getRegressionAbsMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.results.absMean,
            d3.format('.3f')
          );
        },

        getRegressionSquaredMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.results.squaredMean,
            d3.format('.3f')
          );
        },

        getRegressionCount: function(regressionStats, facetItem) {
          const count = this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.results.errors.length,
            null
          );
          if (count == null) {
            return 0;
          } else {
            return count;
          }
        },

        getBinaryClassificationCount: function(classificationStats, facetItem) {
          // stat[0] because we only need to count one threshold in binary case
          return this.getInferenceStat(
            classificationStats,
            facetItem,
            (stat) => Object.values(stat.thresholds[0]).reduce((a, b) => a + b),
            null
          );
        },

        getMulticlassClassificationCount: function(
          classificationStats,
          facetItem
        ) {
          // stat because in multi class case inferenceStats does not have
          // thresholds
          return this.getInferenceStat(
            classificationStats,
            facetItem,
            (stat) =>
              Object.values(stat.results).reduce((a, b) => {
                let total = 0;
                const iKeys = Object.keys(b);
                for (let i = 0; i < iKeys.length; i++) {
                  total += b[iKeys[i]];
                }
                return a + total;
              }, 0),
            null
          );
        },

        getRocChartId: function(index) {
          return 'rocchart' + index;
        },

        getRocChartLabelId: function(label, index) {
          return this.getRocChartId(index) + '-' + label;
        },

        getLabel: function(index) {
          return this.labelVocab[index] || index;
        },

        getPrChartId: function(index) {
          return 'prchart' + index;
        },

        getPrChartLabelId: function(label, index) {
          return this.getPrChartId(index) + '-' + label;
        },

        /**
         * Returns a printable value for a breakdown item, meaning performance
         * statistics broken down by feature values or feature crosses.
         */
        getPrintableValue_: function(item) {
          let str = '';
          if (!item.value && item.value !== 0) {
            str = '<feature value missing>';
          } else {
            str = String(item.value);
          }
          if (this.selectedSecondBreakdownFeature == '') {
            return str;
          }
          str += '/';
          if (!item.value2 && item.value2 !== 0) {
            str += '<feature value missing>';
          } else {
            str += item.value2;
          }
          return str;
        },

        getFeatureName_: function(feature) {
          // If feature name is blank then this represents selecting no feature.
          if (feature.length === 0) {
            return '<none>';
          }
          return feature;
        },

        getLabeledModelName_: function(modelName) {
          return 'Model: ' + modelName;
        },

        getClassName_: function(cls) {
          // If class name is blank then this represents selecting no class.
          if (cls.length === 0) {
            return '<none>';
          }
          return cls;
        },

        shouldShowOverallThresholder_: function(feature) {
          return feature.length === 0;
        },

        /**
         * Sets the selected example from the facets dive selection.
         */
        computeSelectedExampleAndInference: function() {
          this.counterfactualExampleAndInference = null;
          if (!this.selected || !this.examplesAndInferences) {
            this.selectedExampleAndInference = null;
            return;
          }
          this.selectedExampleAndInference =
            this.selected.length > 0
              ? this.examplesAndInferences[this.selected[0]]
              : null;
          if (this.selectedExampleAndInference == null) {
            this.globalPdPlots = true;
          } else {
            this.globalPdPlots = false;
            if (this.visMode != 'dive') {
              this.showPartialDependencePlots_();
            }
          }
        },

        /**
         * Finds attribution features and sets the attribution object for the
         * selected example.
         */
        setAttributions: function() {
          if (!this.selected || this.selected.length == 0) {
            return;
          }
          const attrib = {};
          const selectedData = this.visdata[this.selected[0]];
          const modelNumSuffix = this.attributionStrWithModelName_(
            '',
            this.attributionModelIndex
          );
          const attributionFinder = new RegExp(
            attributionPrefix + '(.*)' + modelNumSuffix
          );
          for (let key in selectedData) {
            let featureWithAttribution = attributionFinder.exec(key);
            // If this feature represents an attribution, set the attribution
            // value for the appropriate example feature.
            // Attribution is represented by features with the format
            // "{attributionPrefix}{featureName}".
            if (featureWithAttribution) {
              const featFinder = new RegExp(
                '^(' +
                  featureForAttributionPrefix +
                  ')?' +
                  featureWithAttribution[1] +
                  '$'
              );
              for (let featToTest in selectedData) {
                if (featFinder.test(featToTest)) {
                  attrib[featToTest] = selectedData[key];
                  break;
                }
              }
            }
          }
          this.attribution = attrib;
        },

        shouldDisableGetExamplesButton_: function(examplesPath) {
          return examplesPath.length == 0;
        },

        shouldDisableInferButton_: function(
          examples,
          modelName,
          inferenceAddress,
          updatedExample
        ) {
          return (
            examples.length == 0 ||
            modelName.length == 0 ||
            inferenceAddress.length == 0 ||
            !updatedExample
          );
        },

        areExamplesEditable_: function(modelName, inferenceAddress) {
          return modelName.length != 0 && inferenceAddress.length != 0;
        },

        newInferences_: function() {
          this.loadingBarHidden_ = true;
          this.updateInferences_(true);
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        refreshInferencesNoRegen_: function() {
          this.refreshInferences_(true);
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        refreshInferences_: function(noRegen) {
          this.updateInferences_(false);
          requestAnimationFrame(() => this.updateInferenceStats_(!noRegen));
        },

        /**
         * Updates inference results.
         */
        updateInferences_: function(newInferencesCalculated) {
          if (
            !this.examplesAndInferences ||
            !this.inferences.indices ||
            this.inferences.indices.length == 0 ||
            this.inferences.results.length != this.numModels
          ) {
            return;
          }
          // Create map of example indices to inference results.
          // inferenceMap: sample id -> # Models -> # Labels
          const inferenceMap = {};
          const isClassification = !!this.inferences.results[0]
            .classificationResult;
          for (let i = 0; i < this.inferences.indices.length; i++) {
            if (isClassification) {
              inferenceMap[this.inferences.indices[i]] = [];
              for (
                let modelNum = 0;
                modelNum < this.inferences.results.length;
                modelNum++
              ) {
                const result = this.inferences.results[modelNum]
                  .classificationResult;
                for (
                  let j = 0;
                  j < result.classifications[i].classes.length;
                  j++
                ) {
                  // For models that don't return any labels for the classes,
                  // fill them out with class indices.
                  if (result.classifications[i].classes[j].label == '') {
                    result.classifications[i].classes[j].label = j.toString();
                  }
                  // If the label matches a string from the label vocab, then
                  // replace the label with the class index as that is what
                  // WIT expects.
                  if (this.labelVocab != null && this.labelVocab.length > 0) {
                    const labelIndex = this.labelVocab.indexOf(
                      result.classifications[i].classes[j].label);
                    if (labelIndex !== -1) {
                      result.classifications[i].classes[j].label =
                        labelIndex.toString();
                    }
                  }
                }
                inferenceMap[this.inferences.indices[i]][
                  modelNum
                ] = result.classifications[i].classes.sort(
                  (a, b) => b.score - a.score
                );
              }
            } else {
              inferenceMap[this.inferences.indices[i]] = [];
              for (
                let modelNum = 0;
                modelNum < this.inferences.results.length;
                modelNum++
              ) {
                const result = this.inferences.results[modelNum]
                  .regressionResult;
                inferenceMap[this.inferences.indices[i]][modelNum] = [
                  {label: '', score: result.regressions[i].value},
                ];
              }
            }
          }
          // Set the inferences in the examplesAndInferences structure, updating
          // for new inferences where appropriate.
          this.set(
            'examplesAndInferences',
            this.examplesAndInferences.map(function(item, index) {
              let inferences = item.inferences ? item.inferences : [];
              if (inferenceMap[index] && newInferencesCalculated) {
                inferences = inferences.concat([inferenceMap[index]]);
              }
              return {
                example: item.example,
                inferences: inferences,
                changed: item.changed,
                orig: item.orig,
              };
            })
          );
          const self = this;
          let hasInferenceLabels = false;
          this.visdata.forEach(function(item, index) {
            if (isClassification) {
              self.setItemInferenceValue(
                item,
                index,
                self.selectedBreakdownFeature,
                self.selectedSecondBreakdownFeature
              );
            } else {
              for (let modelInd = 0; modelInd < self.numModels; modelInd++) {
                item[self.strWithModelName_(inferenceValueStr, modelInd)] =
                  self.examplesAndInferences[index].inferences[
                    self.examplesAndInferences[index].inferences.length - 1
                  ][modelInd][0].score;
              }
            }

            // If there is a label vocab for classification, set the string
            // inferred label for each example.
            if (isClassification && self.labelVocab.length > 0) {
              for (
                let inferenceIndex = 0;
                inferenceIndex <
                self.examplesAndInferences[index].inferences.length;
                inferenceIndex++
              ) {
                for (
                  let modelNum = 0;
                  modelNum <
                  self.examplesAndInferences[index].inferences[inferenceIndex]
                    .length;
                  modelNum++
                ) {
                  for (
                    let labelIndex = 0;
                    labelIndex <
                    self.examplesAndInferences[index].inferences[
                      inferenceIndex
                    ][modelNum].length;
                    labelIndex++
                  ) {
                    self.examplesAndInferences[index].inferences[
                      inferenceIndex
                    ][modelNum][labelIndex].vocabLabel =
                      self.labelVocab[
                        self.examplesAndInferences[index].inferences[
                          inferenceIndex
                        ][modelNum][labelIndex].label
                      ];
                  }
                }
              }
              for (let modelInd = 0; modelInd < self.numModels; modelInd++) {
                item[self.strWithModelName_(inferenceLabelStr, modelInd)] =
                  self.labelVocab[
                    item[self.strWithModelName_(inferenceValueStr, modelInd)]
                  ];
              }
              hasInferenceLabels = true;
            }
          });
          this.updateCorrectness_();
          this.refreshDive_();

          // If inferring for the first time, set the color in facets dive to
          // inference results of the first model and use positioning to show
          // inference scores. When reinferring from changes, don't override
          // whatever options have been set.
          if (
            this.inferences.indices.length == this.examplesAndInferences.length
          ) {
            this.$.dive.colorBy = hasInferenceLabels
              ? this.strWithModelName_(inferenceLabelStr, 0)
              : this.strWithModelName_(inferenceValueStr, 0);
            if (this.isRegression_(this.modelType)) {
              this.$.dive.horizontalPosition = this.strWithModelName_(
                inferenceValueStr,
                0
              );
              if (this.numModels > 1) {
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceValueStr,
                  1
                );
              }
            } else if (
              this.isBinaryClassification_(this.modelType, this.multiClass)
            ) {
              if (this.numModels == 1) {
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  0
                );
              } else {
                this.$.dive.horizontalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  0
                );
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  1
                );
              }
            }
          }
          this.updatedExample = false;
        },

        hasAttributions_: function(attributions) {
          return (
            attributions != null &&
            Object.keys(attributions.attributions).length != 0 &&
            attributions.attributions[0] != null
          );
        },

        hasMultipleModelAttributions_: function(attributions) {
          return (
            attributions != null &&
            Object.keys(attributions.attributions).length > 1 &&
            attributions.attributions[0] != null &&
            attributions.attributions[1] != null
          );
        },

        newExtraOutputs_: function(extraOutputs) {
          // Set attributions from the extra outputs, if available.
          const attributions = [];
          for (
            let modelNum = 0;
            modelNum < extraOutputs.extra.length;
            modelNum++
          ) {
            if (
              extraOutputs.extra[modelNum] != null &&
              'attributions' in extraOutputs.extra[modelNum]
            ) {
              attributions.push(extraOutputs.extra[modelNum].attributions);
            }
          }
          if (attributions.length > 0) {
            this.attributions = {
              indices: extraOutputs.indices,
              attributions: attributions,
            };
          }

          // Add extra output information to datapoints
          for (let i = 0; i < extraOutputs.indices.length; i++) {
            const idx = extraOutputs.indices[i];
            const datapoint = Object.assign({}, this.visdata[idx]);
            for (
              let modelNum = 0;
              modelNum < extraOutputs.extra.length;
              modelNum++
            ) {
              if (extraOutputs.extra[modelNum] == null) {
                continue;
              }
              const keys = Object.keys(extraOutputs.extra[modelNum]);
              for (let j = 0; j < keys.length; j++) {
                const key = keys[j];
                // Skip attributions as they are handled separately above.
                if (key == 'attributions') {
                  continue;
                }
                let val = extraOutputs.extra[modelNum][key][i];
                const datapointKey = this.strWithModelName_(key, modelNum);

                // Update the datapoint with the extra info for use in
                // Facets Dive.
                datapoint[datapointKey] = val;

                // Convert the extra output into an array if necessary, for
                // insertion into tf.Example as a value list, for update of
                // examplesAndInferences for the example viewer.
                if (!Array.isArray(val)) {
                  val = [val];
                }
                const isString =
                  val.length > 0 &&
                  (typeof val[0] == 'string' || val[0] instanceof String);
                const exampleJsonString = JSON.stringify(
                  this.examplesAndInferences[idx].example
                );
                const copiedExample = JSON.parse(exampleJsonString);
                copiedExample.features.feature[datapointKey] = isString
                  ? {bytesList: {value: val}}
                  : {floatList: {value: val}};
                this.examplesAndInferences[idx].example = copiedExample;
              }
            }
            this.set(`visdata.${idx}`, datapoint);
          }
          this.refreshDive_();

          // Update selected datapoint so that if a datapoint is being viewed,
          // the display is updated with the appropriate extra output.
          this.computeSelectedExampleAndInference();
          this.refreshSelectedDatapoint_();
        },

        newAttributions_: function(attributions) {
          if (!this.hasAttributions_(attributions)) {
            return;
          }
          if (this.allAttributions_.length < this.visdata.length) {
            const newEntries = [...new Array(
                this.visdata.length - this.allAttributions_.length)
                ].map(() => [...new Array(this.numModels)].map(() => {return {};}));
            this.allAttributions_ = this.allAttributions_.concat(newEntries);
          }
          for (let i = 0; i < attributions.indices.length; i++) {
            const idx = attributions.indices[i];
            const datapoint = Object.assign({}, this.visdata[idx]);
            for (
              let modelNum = 0;
              modelNum < attributions.attributions.length;
              modelNum++
            ) {
              const attribs =
                attributions.attributions[modelNum] == null
                  ? {}
                  : attributions.attributions[modelNum][i];
              const keys = Object.keys(attribs);
              for (let j = 0; j < keys.length; j++) {
                // An attribution is a single value or list of values for each feature.
                // TODO(jameswex): Better handle case when only one model of two
                // provided has attributions.
                let attribKey = this.attributionStrWithModelName_(
                  attributionPrefix + keys[j],
                  modelNum
                );
                datapoint[attribKey] = attribs[keys[j]];
                let newAttributions = Array.isArray(datapoint[attribKey])
                  ? datapoint[attribKey]
                  : [datapoint[attribKey]];
                this.allAttributions_[idx][modelNum][keys[j]] = newAttributions;
                for (
                  let attribIdx = 0;
                  attribIdx < newAttributions.length;
                  attribIdx++
                ) {
                  if (newAttributions[attribIdx] > this.maxAttribution) {
                    this.maxAttribution = newAttributions[attribIdx];
                  }
                  if (newAttributions[attribIdx] < this.minAttribution) {
                    this.minAttribution = newAttributions[attribIdx];
                  }
                }
              }
            }
            this.set(`visdata.${idx}`, datapoint);
          }
          // Make min/max symmetric around 0 so that attribution visualization scales
          // for negative and positive attributions are the same, for visual
          // consistency.
          if (
            this.minAttribution < 0 &&
            this.maxAttribution > Math.abs(this.minAttribution)
          ) {
            this.minAttribution = -1 * this.maxAttribution;
          } else if (
            this.maxAttribution > 0 &&
            Math.abs(this.minAttribution) > this.maxAttribution
          ) {
            this.maxAttribution = -1 * this.minAttribution;
          }
          this.setAttributions();
          this.createAttributionLegend();
          this.refreshDive_();
        },

        // Create and display the attribution legend.
        createAttributionLegend: function() {
          let attributionDomain = [];
          let attributionColorRange = [];
          if (this.minAttribution < 0) {
            attributionDomain.push(this.minAttribution);
            attributionColorRange.push(negAttributionHighColor);
            attributionDomain.push(this.minAttribution / 5);
            attributionColorRange.push(negAttributionLowColor);
          }
          attributionDomain.push(0);
          attributionColorRange.push(neutralAttributionColor);
          if (this.maxAttribution > 0) {
            attributionDomain.push(this.maxAttribution / 5);
            attributionColorRange.push(posAttributionLowColor);
            attributionDomain.push(this.maxAttribution);
            attributionColorRange.push(posAttributionHighColor);
          }

          this.attributionColorScale = d3
            .scaleLinear()
            .domain(attributionDomain)
            .interpolate(COLOR_INTERPOLATOR)
            .clamp(true)
            .range(attributionColorRange);

          const attrLegend = Polymer.dom(this.root).querySelector(
            '#attributionLegend'
          );
          d3.select(attrLegend)
            .selectAll('*')
            .remove();
          const legendSvg = d3.select(attrLegend).append('g');
          const gradient = legendSvg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'vzexampleviewergradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '100%')
            .attr('y2', '0%')
            .attr('spreadMethod', 'pad');

          const linspace = (start, end, n) => {
            const out = [];
            const delta = (end - start) / (n - 1);
            let i = 0;
            while (i < n - 1) {
              out.push(start + i * delta);
              i++;
            }
            out.push(end);
            return out;
          };

          // Set 3 ticks on the legend, handling all positive, all negative,
          // or a mix of both.
          const ticks = [];
          if (attributionColorRange.length == 5) {
            ticks.push(this.minAttribution / 2);
            ticks.push(0);
            ticks.push(this.maxAttribution / 2);
          } else if (this.minAttribution < 0) {
            ticks.push((this.minAttribution / 4) * 3);
            ticks.push(this.minAttribution / 2);
            ticks.push((this.minAttribution / 4) * 1);
          } else {
            ticks.push((this.maxAttribution / 4) * 1);
            ticks.push(this.maxAttribution / 2);
            ticks.push((this.maxAttribution / 4) * 3);
          }
          // Creates an array of [pct, colour] pairs as stop
          // values for legend
          const low = attributionDomain[0];
          const range = attributionDomain[attributionDomain.length - 1] - low;
          const pct = attributionDomain.map((d) => {
            const perc = Math.round(((d - low) / range) * 100);
            return perc + '%';
          });

          const colourPct = d3.zip(pct, attributionColorRange);

          colourPct.forEach((d) => {
            gradient
              .append('stop')
              .attr('offset', d[0])
              .attr('stop-color', d[1])
              .attr('stop-opacity', 1);
          });

          legendSvg
            .append('rect')
            .attr('x1', 0)
            .attr('y1', 0)
            .attr('width', LEGEND_WIDTH_PX)
            .attr('height', LEGEND_HEIGHT_PX)
            .style('fill', 'url(#vzexampleviewergradient)');

          const legendScale = d3
            .scaleLinear()
            .domain([this.minAttribution, this.maxAttribution])
            .range([0, LEGEND_WIDTH_PX]);

          const legendAxis = d3
            .axisBottom(legendScale)
            .tickValues(ticks)
            .tickSize(4)
            .tickFormat(d3.format('.1f'));

          legendSvg
            .append('g')
            .attr('class', 'legend axis')
            .attr('transform', `translate(0,${LEGEND_HEIGHT_PX})`)
            .style('font', '9px')
            .call(legendAxis);
        },

        /**
         * Helper method for setting inference value for classifications.
         */
        setItemInferenceValue: function(item, index, feature1, feature2) {
          const inferenceIdx =
            this.examplesAndInferences[index].inferences.length - 1;
          if (this.multiClass) {
            for (let i = 0; i < this.numModels; i++) {
              item[
                this.strWithModelName_(inferenceValueStr, i)
              ] = this.examplesAndInferences[index].inferences[inferenceIdx][
                i
              ][0].label;
            }
            return;
          }

          // Binary classifier case.
          let thresholds = this.overallThresholds;
          // If a feature has been selected (string will be non-empty in this
          // case), then get the appropriate threshold for this item's value for
          // that feature. Otherwise the overall threshold will be used.
          if (feature1.length !== 0) {
            let key = this.getSliceKey_(
              item,
              this.selectedBreakdownFeature,
              this.selectedSecondBreakdownFeature
            );
            thresholds = this.featureValueThresholds[
              this.featureValueThresholdsIndexMap[key]
            ].threshold;
          }
          for (let modelNum = 0; modelNum < this.numModels; modelNum++) {
            const nonZeroClassification = this.getClassificationBestNonZero(
              index,
              modelNum
            );
            item[this.strWithModelName_(inferenceScoreStr, modelNum)] =
              nonZeroClassification.score;
            if (nonZeroClassification.score >= thresholds[modelNum].threshold) {
              item[this.strWithModelName_(inferenceValueStr, modelNum)] =
                nonZeroClassification.label;
            } else {
              item[
                this.strWithModelName_(inferenceValueStr, modelNum)
              ] = this.defaultInferenceLabel.toString();
            }
          }
        },

        createCombinedValueString_: function(val1, val2) {
          let str = val1 === undefined || val1 === null ? '' : val1;
          if (val2 === undefined || val2 === null || val2 === '') {
            return str;
          }
          return str + '/' + val2;
        },

        /**
         * Updates per-item results for display in facets dive based on inference.
         */
        updateCorrectness_: function() {
          if (!this.selectedLabelFeature || !this.examplesAndInferences) {
            return;
          }
          for (let i = 0; i < this.examplesAndInferences.length; i++) {
            const item = this.visdata[i];
            for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
              if (this.modelType == 'classification') {
                item[this.strWithModelName_(inferenceCorrectStr, modelInd)] =
                  item[this.selectedLabelFeature] ==
                  item[this.strWithModelName_(inferenceValueStr, modelInd)]
                    ? 'correct'
                    : 'incorrect';
              } else {
                item[this.strWithModelName_(inferenceErrorStr, modelInd)] =
                  item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                  item[this.selectedLabelFeature];
                item[
                  this.strWithModelName_(inferenceAbsErrorStr, modelInd)
                ] = Math.abs(
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)]
                );
                item[
                  this.strWithModelName_(inferenceSquaredErrorStr, modelInd)
                ] =
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)] *
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)];
              }
            }
          }
        },

        /**
         * Handler for when running inference, calls the backend.
         */
        inferClicked_: function() {
          const inferParams = {
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            label_vocab_path: this.labelVocabPath,
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };
          this.loadingBarHidden_ = false;
          if (!this.local) {
            let tempInferences = [];
            let tempExtraOutputs = [];
            const url = this.makeUrl_('/data/plugin/whatif/infer', inferParams);
            const inferContents = (result) => {
              if (result.value.vocab != null) {
                this.labelVocab = /** @type {!Array} */ (JSON.parse(
                  result.value.vocab
                ));
              }
              tempInferences.push(JSON.parse(result.value.inferences));
              tempExtraOutputs.push(JSON.parse(result.value.extraOutputs));
              if (result.value.next === -1) {
                this.loadingBarHidden_ = true;
                const inferences = this.combineInferences_(tempInferences);
                const extraOutputs = this.combineExtraOutputs_(
                  tempExtraOutputs);
                this.inferences = /** @type {!Object} */ inferences;
                this.extraOutputs = {
                  indices: inferences.indices,
                  extra: extraOutputs
                };
              } else {
                const url = this.makeUrl_('/data/plugin/whatif/infer', {
                  start_example: result.value.next,
                  model_type: this.modelType,
                });
                this.makeAsyncRequest_(url, inferContents, null, 'Model inference');
              }
            };
            this.makeAsyncRequest_(url, inferContents, null, 'Model inference');
          }
          this.fire('infer-examples', inferParams);
        },

        combineInferences_: function(inferences) {
          // Outer loop is all the chunked responses.
          for (let i = 1; i < inferences.length; i++) {
            inferences[0].indices = inferences[0].indices.concat(
              inferences[i].indices);
            // Inner loop are individual examples.
            for (let j = 0; j < inferences[0].results.length; j++) {
              if (this.modelType == 'classification') {
                inferences[0].results[j].classificationResult.classifications =
                inferences[0].results[j].classificationResult.classifications.concat(
                  inferences[i].results[j].classificationResult.classifications);
              } else {
                inferences[0].results[j].regressionResult.regressions =
                inferences[0].results[j].regressionResult.regressions.concat(
                  inferences[i].results[j].regressionResult.regressions);
              }
            }
          }
          return inferences[0];
        },

        combineExtraOutputs_: function(extraOutputs) {
          // Outer loop is all the chunked responses.
          for (let i = 1; i < extraOutputs.length; i++) {
            // Inner loop are individual examples.
            for (let j = 0; j < extraOutputs[0].length; j++) {
              if (extraOutputs[i][j] == null) {
                continue;
              }
              const keys = Object.keys(extraOutputs[i][j]);
              // Keys are the keys for each example's extra output fields.
              for (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {
                const key = keys[keyIndex];
                extraOutputs[0][j][key] =
                  extraOutputs[0][j][key].concat(extraOutputs[i][j][key]);
              }
            }
          }
          return extraOutputs[0];
        },

        /**
         * Handler for an example being changed by user input.
         */
        exampleChange_: function(event) {
          var id = 0;
          var index = this.selected.length == 0 ? id : this.selected[id];
          this.set('selectedExampleAndInference.changed', true);
          this.updateExample_(JSON.stringify(event.target.json), index);
          const inferenceViewerIdStr = '#' + this.getInferenceHolderId_();
          const inferenceViewer = this.$$(inferenceViewerIdStr);
          inferenceViewer.inference = null;
          this.visdata[index] = this.exampleToDataPoint_(
            event.target.json,
            index
          );
          this.showNearestCounterfactual = false;
          this.refreshDive_();
          this.updatedExample = true;
          this.selectedDataUpdated_();
        },

        refreshDiveImpl_: function() {
          const temp = this.visdata;
          this.visdata = [];
          this.visdata = temp;
          this.selectedExampleMax = this.visdata.length - 1;
          this.$.overview.protoInput = this.$.overview.getStatsProto([
            {name: '', data: temp},
          ]);
          this.calculateDistanceStats_(this.$.overview.protoInput.toObject());
          if (this.isRegression_(this.modelType)) {
            this.adjustMinCounterfactualValueDist_();
          }
          const tempSelected = this.$.dive.selectedData;
          this.$.dive.selectedData = [];
          this.$.dive.selectedData = tempSelected;
          this.updateSprite();
        },

        refreshDive_: function() {
          // Debounce a refresh request, for when multiple updates are happening
          // in succession.
          this.debounce(
            'refreshDiveDebounce',
            () => this.refreshDiveImpl_(),
            500
          );
        },

        /**
         * Calculates and stores distance stats for each feature, used for
         * calculating distances between examples.
         */
        calculateDistanceStats_: function(statsProto) {
          this.distanceStats_ = {};
          for (
            let i = 0;
            i < statsProto.datasetsList[0].featuresList.length;
            i++
          ) {
            const featureStats = statsProto.datasetsList[0].featuresList[i];
            const feature = featureStats.name;
            this.distanceStats_[feature] = {
              isNumeric: featureStats.numStats != null,
            };
            if (this.distanceStats_[feature].isNumeric) {
              // Numeric features:
              this.distanceStats_[feature].stdDev =
                featureStats.numStats.stdDev;
            } else {
              // Categorical features: calculate and store the probability
              // that any two feature values across all examples are the same.
              let probSameValue = 0;
              const buckets =
                featureStats.stringStats.rankHistogram.bucketsList;
              for (let j = 0; j < buckets.length; j++) {
                const probEntry =
                  buckets[j].sampleCount /
                  featureStats.stringStats.commonStats.numNonMissing;
                probSameValue += probEntry * probEntry;
              }
              this.distanceStats_[feature].probSameValue = probSameValue;
            }
          }
        },

        /**
         * Whether the feature is numeric (as opposed to categorical).
         */
        isNumericFeature_: function(feature) {
          return (
            feature &&
            this.distanceStats_ &&
            this.distanceStats_[feature] &&
            this.distanceStats_[feature].isNumeric
          );
        },

        /**
         * Calculate edges between buckets for aggregating numeric features.
         * We do this beforehand to round numbers and avoid ugly interval labels.
         */
        calculateBucketEdges_: function(feature, numBuckets) {
          if (
            !this.isNumericFeature_(feature) ||
            // No point in aggregating if not more unique values than buckets.
            this.stats[feature].uniqueCount <= numBuckets ||
            // Already done.
            (this.featureBucketEdges_[feature] &&
              this.featureBucketEdges_[feature].length == numBuckets + 1)
          ) {
            delete this.featureBucketEdges_[feature];
            return;
          }
          const min = this.stats[feature].numberMin;
          const max = this.stats[feature].numberMax;
          const len = (max - min) / numBuckets;
          const stdDev = this.distanceStats_[feature].stdDev;
          function round(val) {
            // Round to slightly more precise than the magnitude of standard deviation.
            const precision = -Math.floor(Math.log10(stdDev)) + 1;
            return Math.round(val * 10 ** precision) / 10 ** precision;
          }
          const bucketEdges = [];
          bucketEdges.push(min);
          for (let i = 1; i < numBuckets; i++) {
            bucketEdges.push(round(min + i * len));
          }
          bucketEdges.push(max);
          this.featureBucketEdges_[feature] = bucketEdges;
        },

        /**
         * Calls the backend to update a changed example.
         */
        updateExample_: function(exampleJson, index) {
          this.fire('update-example', {example: exampleJson, index: index});
          if (!this.local) {
            var url = this.makeUrl_('/data/plugin/whatif/update_example', null);

            this.makeAsyncRequest_(
              url,
              null,
              {example: exampleJson, index: index},
              'Datapoint update'
            );
          }
        },

        getInferenceHolderId_: function() {
          return 'inference_';
        },

        makeUrl_: function(prefix, paramsDict) {
          const url = prefix;
          if (paramsDict) {
            prefix +=
              '?' +
              Object.keys(paramsDict)
                .map((k) => k + '=' + encodeURIComponent(paramsDict[k]))
                .join('&');
          }
          return prefix;
        },

        showToast_: function(msg) {
          var toast = document.createElement('paper-toast');
          toast.duration = 10000;
          document.body.appendChild(toast);
          toast.text = msg;
          toast.show();

          // Also, log to console.
          console.error(msg);
        },

        handleError: function(errorStr) {
          this.showToast_(errorStr);
          this.exampleStatusStr = errorStr;
          this.loadingBarHidden_ = true;
          this.isSortingEligibleFeatures = false;
        },

        makeAsyncRequest_: function(
          url,
          thenDoFn,
          postData,
          readableRequestName,
          errorFn = () => {}
        ) {
          const wrapperFn = this._canceller.cancellable((result) => {
            if (result.cancelled) {
              return;
            }
            if (result.value && result.value.error) {
              this.handleError(result.value.error);
              if (errorFn != null) {
                errorFn();
              }
            } else if (thenDoFn) {
              thenDoFn(result);
            }
          });
          this._requestManager
            .request(url, postData)
            .then(wrapperFn)
            .catch((reason) => {
              this.handleError(
                `${readableRequestName} failed: ${reason.req.responseText}`
              );
              if (errorFn != null) {
                errorFn();
              }
            });
        },

        /**
         * Extract the data point feature value from an example feature. If
         * squeeze is true then convert length 1 arrays into single objects.
         */
        dataPointValueFromFeature_: function(feature, squeeze) {
          let valueList = null;
          if (feature.int64List) {
            valueList = feature.int64List.value;
          } else if (feature.floatList) {
            valueList = feature.floatList.value;
          } else if (feature.bytesList && feature.bytesList.value) {
            valueList = feature.bytesList.value.map((val) => {
              // Strings above a max length are most likely binary encoded data
              // and not strings and therefore shouldn't be decoded for display
              // in Facets Dive.
              if (val.length > maxStringLengthToDecode) {
                return 'ERROR: string not decoded due to length';
              }
              try {
                return atob(val);
              } catch (err) {
                console.error('Error decoding string: ' + err);
                return 'ERROR: error decoding string';
              }
            });
          }
          // For value lists that are of length 1, treat the feature value
          // as just the item and not the list of length 1.
          if (squeeze && valueList && valueList.length == 1) {
            let singleValue = valueList[0];
            // For numeric feature values, convert the string to a number.
            if (!isNaN(singleValue)) {
              return Number(singleValue);
            } else {
              return singleValue;
            }
          }
          return valueList;
        },

        /**
         * Converts a single TF Example or SequenceExample into an item dict for
         * display in Facets Dive.
         */
        exampleToDataPoint_: function(example, index) {
          const d = {};
          // Extract the standard features from examples or context features from
          // sequence examples.
          const featureRoot = example.features || example.context;
          const features =
            featureRoot && 'feature' in featureRoot
              ? Object.keys(featureRoot.feature)
              : [];
          for (const index in features) {
            const fname = features[+index];
            // Ignore encoded image feature when creating data for Facets Dive.
            // The image will instead be used for the display sprite for the item
            // in Dive.
            if (fname == this.imageFeatureName) {
              continue;
            }
            let v = this.dataPointValueFromFeature_(
              featureRoot.feature[fname],
              true
            );
            if (v != null) {
              d[fname] = v;
            }
          }

          // For sequence examples, extract the sequence feature values.
          const featureLists =
            'featureLists' in example
              ? Object.keys(example.featureLists.featureList)
              : [];
          for (const index in featureLists) {
            const fname = featureLists[+index];
            const fList = example.featureLists.featureList[fname].feature;
            let v = [];
            // Concatenate feature values from all values in the sequence for
            // each feature.
            for (let i = 0; i < fList.length; i++) {
              const newV = this.dataPointValueFromFeature_(fList[i], false);
              if (newV) {
                v = v.concat(newV);
              }
            }
            d[fname] = v;
          }
          d[exampleIdKey] = index;
          return d;
        },

        getExamplesAndCloseSettings_: function() {
          this.settingsClicked_();
          this.updateNumberOfModels();
          this.getExamples_();
        },

        showModelNumbers_: function() {
          return this.numModels <= 1;
        },

        /**
         * Callback for when new examples are received from the backend.
         */
        updateExampleContents: function(examples, hasSprite) {
          this.exampleStatusStr = examples.length + ' datapoints loaded';
          this.$.noexamples.style.display = 'none';
          this.loadingBarHidden_ = true;
          this.examplesAndInferences = examples.map(function(ex) {
            const example = JSON.parse(ex);
            return {example: example, changed: false, orig: JSON.parse(ex)};
          });
          this.updatedExample = true;
          const self = this;
          this.visdata = this.examplesAndInferences.map(function(ex, i) {
            return self.exampleToDataPoint_(ex.example, i);
          });
          this.$.dive.atlasUrl = '';
          this.$.dive.imageFieldName = '';
          this.hasSprite = hasSprite;
          this.refreshDive_();
          if (
            !this.shouldDisableInferButton_(
              this.examplesAndInferences,
              this.modelName,
              this.inferenceAddress,
              this.updatedExample
            )
          ) {
            this.inferClicked_();
          }
          this.setInferenceFromExampleData();
        },

        /**
         * If the example data contains inference results, as in the case with
         * pre-computed model results, then set the appropriate inference results.
         */
        setInferenceFromExampleData: function() {
          // If the examples contain the classification results or regression
          // results keys, then set the classification results from the
          // information in the examples.
          if (this.visdata.length > 0) {
            if (this.visdata[0][classificationResultsKey] != null) {
              const inferences = {};
              const indices = Array.apply(null, {
                length: this.visdata.length,
              }).map(Number.call, Number);
              inferences.indices = indices;
              inferences.results = [
                {classificationResult: {classifications: []}},
              ];
              for (let i = 0; i < indices.length; i++) {
                inferences.results[0].classificationResult.classifications[
                  i
                ] = {
                  classes: [
                    {
                      label: '0',
                      score: this.visdata[i][classificationResultsKey][0],
                    },
                    {
                      label: '1',
                      score: this.visdata[i][classificationResultsKey][1],
                    },
                  ],
                };
              }
              this.inferences = inferences;
            } else if (this.visdata[0][regressionResultsKey] != null) {
              const inferences = {};
              const indices = Array.apply(null, {
                length: this.visdata.length,
              }).map(Number.call, Number);
              inferences.indices = indices;
              inferences.results = [{regressionResult: {regressions: []}}];
              for (let i = 0; i < indices.length; i++) {
                inferences.results[0].regressionResult.regressions[i] = {
                  value: this.visdata[i][regressionResultsKey],
                };
              }
              this.inferences = inferences;
            }
          }
        },

        getExamples_: function() {
          let tempExamples = [];
          let tempSprite = null;
          const url = this.makeUrl_('/data/plugin/whatif/examples_from_path', {
            examples_path: this.examplesPath,
            max_examples: this.maxExamples,
            sampling_odds: this.samplingOdds,
            sequence_examples: this.sequenceExamples,
          });

          const updateExampleContents = (result) => {
            tempExamples = tempExamples.concat(result.value.examples);
            if (result.value.sprite != null) {
              tempSprite = result.value.sprite;
            }
            if (result.value.next === -1) {
              this.updateExampleContents(
                tempExamples,
                tempSprite
              );
            } else {
              const url = this.makeUrl_('/data/plugin/whatif/examples_from_path', {
                start_example: result.value.next
              });
              this.makeAsyncRequest_(
                url,
                updateExampleContents,
                null,
                'Datapoint load'
              );
            }
          };
          this.exampleStatusStr = 'Loading datapoints...';
          this.makeAsyncRequest_(
            url,
            updateExampleContents,
            null,
            'Datapoint load'
          );
          this.loadingBarHidden_ = false;
        },

        updateSprite: function() {
          if (this.hasSprite) {
            this.$.dive.atlasUrl = null;
            if (!this.local) {
              this.$.dive.atlasUrl = this.makeUrl_(
                '/data/plugin/whatif/sprite',
                {}
              );
            } else {
              this.$.dive.atlasUrl = this.localAtlasUrl;
            }
          }
        },

        selectedDataUpdated_: function() {
          this.selectedExampleNum =
            this.selected.length > 0 ? this.selected[0] : '';
          if (this.visdata && this.visdata.length > 0) {
            this.partialDepPlotPendingFeatures = [];
          }
        },

        /**
         * Handler for copying a datapoint to a new datapoint.
         */
        copyDatapoint_: function() {
          const exampleJsonString = JSON.stringify(
            this.selectedExampleAndInference.example
          );
          const example = JSON.parse(exampleJsonString);
          const exampleAndInference = {
            example: example,
            changed: false,
            orig: JSON.parse(exampleJsonString),
          };
          this.examplesAndInferences.push(exampleAndInference);
          this.selectedExampleAndInference = exampleAndInference;
          this.visdata.push(
            this.exampleToDataPoint_(
              exampleAndInference.example,
              this.visdata.length
            )
          );
          const duplicatedIndex = this.selected[0];

          this.showNearestCounterfactual = false;

          // Automatically select the new datapoint.
          this.selected[0] = this.visdata.length - 1;
          this.selectedDataUpdated_();

          this.updatedExample = true;

          // Inform the backend of the new example.
          this.fire('duplicate-example', {index: duplicatedIndex});
          if (!this.local) {
            const refreshDiveAfterDuplicate = (result) => {
              this.refreshDive_();
            };
            const url = this.makeUrl_('/data/plugin/whatif/duplicate_example', {
              index: duplicatedIndex,
            });
            this.makeAsyncRequest_(
              url,
              refreshDiveAfterDuplicate,
              null,
              'Datapoint duplication'
            );
          } else {
            this.refreshDive_();
          }
        },

        deleteDatapointDialog_: function() {
          this.$.deletedialog.open();
        },

        /**
         * Handler for deleting a datapoint.
         */
        deleteDatapoint_: function() {
          // Remove the datapoint, unselect it, and inform the backend.
          const deletedIndex = this.selected[0];
          this.examplesAndInferences.splice(deletedIndex, 1);
          this.visdata.splice(deletedIndex, 1);

          // Fix example IDs due to deleted index.
          for (let i = deletedIndex; i < this.visdata.length; i++) {
            this.visdata[i][exampleIdKey] = i;
          }

          this.comparedIndices = [];
          this.selected = [];
          this.selectedDataUpdated_();
          this.fire('delete-example', {index: deletedIndex});
          this.$.dive.selectedIndices = [];
          if (!this.local) {
            const refreshDiveAfterDelete = (result) => {
              this.refreshDive_();
            };
            const url = this.makeUrl_('/data/plugin/whatif/delete_example', {
              index: deletedIndex,
            });
            this.makeAsyncRequest_(
              url,
              refreshDiveAfterDelete,
              null,
              'Datapoint delete'
            );
          } else {
            this.refreshDive_();
          }
        },

        shouldDisableReset_: function(exampleChanged) {
          return !exampleChanged;
        },

        /**
         * Handler for resetting an edited datapoint.
         */
        resetDatapoint_: function() {
          // Force reset of example in example viewer component by clearing out
          // the example and then waiting a frame to set it back to the original
          // value.
          this.set('selectedExampleAndInference.example', {});

          requestAnimationFrame(() => {
            this.selectedExampleAndInference.changed = false;
            const origExampleJsonString = JSON.stringify(
              this.selectedExampleAndInference.orig
            );
            this.set(
              'selectedExampleAndInference.example',
              JSON.parse(origExampleJsonString)
            );
            this.visdata[this.selected[0]] = this.exampleToDataPoint_(
              this.selectedExampleAndInference.example,
              this.selected[0]
            );
            this.updatedExample = true;
            this.updateExample_(origExampleJsonString, this.selected[0]);
            this.refreshDive_();
          });
        },

        /**
         * Add a partial dependence plot for a given feature.
         */
        addChart: function(chartType, featureName, data) {
          let chart;
          let dataToChart = data;

          // If multiclass and there are more inferred classes than the set
          // number of classes to display, then filter the classes to display
          // in the chart down to the top scoring classes.
          if (this.isMultiClass_(this.modelType, this.multiClass)) {
            dataToChart = [];
            for (let modelIdx = 0; modelIdx < data.length; modelIdx++) {
              let modelDataToChart = {};
              if (
                Object.keys(data[modelIdx]).length >
                Number(this.maxInferenceEntriesPerRun)
              ) {
                const exampleId =
                  this.selected && this.selected.length > 0
                    ? this.selected[0]
                    : 0;
                // Get the class labels of the top scoring classes from the most
                // recent inference.
                const currentExample = this.examplesAndInferences[exampleId];
                const lastInference =
                  currentExample.inferences[
                    currentExample.inferences.length - 1
                  ];
                const labels = lastInference[modelIdx].slice(
                  0,
                  this.maxInferenceEntriesPerRun
                );
                for (let labelIdx = 0; labelIdx < labels.length; labelIdx++) {
                  const label = labels[labelIdx].label;
                  modelDataToChart[label] = data[modelIdx][label];
                }
              } else {
                modelDataToChart = data[modelIdx];
              }
              dataToChart.push(modelDataToChart);
            }
          }

          if (chartType == 'numeric') {
            chart = this.makeLineChart(featureName, dataToChart);
          } else if (chartType == 'categorical') {
            chart = this.makeBarChart(featureName, dataToChart);
          } else {
            console.error('Unknown chartType: ' + chartType);
          }

          const container = this.featureContainerByName(featureName);

          // Append chart
          const categoryPane = container.querySelector(
            '.tf-category-pane-content'
          );
          Polymer.dom(categoryPane).appendChild(chart);

          // Remove the feature from pending queue, so it can be called again.
          const feature_ind = this.partialDepPlotPendingFeatures.indexOf(
            featureName
          );
          if (feature_ind > -1) {
            this.partialDepPlotPendingFeatures.splice(feature_ind, 1);
          }
        },

        getSimpleAxisFormatter: function(precision) {
          return Plottable.Formatters.general(precision);
        },

        makeBarChart: function(featureName, data) {
          // array of categorical data objects (keys are labels):
          // {"1": [{"step": ["Divorced"], "scalar": 0.1533520370721},
          //    {"step": ["Married-AF-spouse"], "scalar": 0.153403326869}]},
          // one object per model

          function convertPoint(point, origKey) {
            // point: {"step": ["Divorced"], "scalar": 0.1533520370721817}
            return {
              x:
                point.step == origKey
                  ? point.step + ' - original value'
                  : point.step,
              y: point.scalar,
            };
          }

          function convertThreshold(point, origKey, threshold) {
            return {
              x:
                point.step == origKey
                  ? point.step + ' - original value'
                  : point.step,
              scalar: point.scalar,
              y: threshold,
            };
          }

          // Overwrite the key for original value so that it reads under the bar
          let origKey = '';
          const firstModelValues = data[0];
          if (!this.globalPdPlots) {
            const origValEntry = this.createPdEntryForCurrentValue(
              featureName,
              firstModelValues,
              0
            );
            if (origValEntry) {
              origKey = origValEntry.step;
            }
          }

          // Convert the data into the format expected by vz-bar-chart.
          // Stack models and labels so that each (model,label) is a separate
          // series
          const lines = {};
          const mapped = {};
          const self = this;
          _.forEach(data, (modelValues, modelInd) => {
            const obj = _.forEach(modelValues, (pointsForSeries, labelKey) => {
              // Sort bars by their inference values for display.
              mapped[
                this.formatChartKey(labelKey, modelInd, data.length)
              ] = _.map(pointsForSeries, (point) =>
                convertPoint(point, origKey)
              ).sort((a, b) => b.y - a.y);
              // For binary classifiers, also create lines to indicate the
              // classification threshold for each model, with datapoints
              // sorted by the inference values to match the bar order for
              // the bar chart it will be displayed over.
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                lines[
                  this.formatChartKey(labelKey, modelInd, data.length)
                ] = _.map(pointsForSeries, (point) =>
                  convertThreshold(
                    point,
                    origKey,
                    this.overallThresholds[modelInd].threshold
                  )
                ).sort((a, b) => b.scalar - a.scalar);
              }
            });
          });

          const valueFormatter = vz_chart_helpers.multiscaleFormatter(
            vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION
          );
          const toolTipColumns = [
            {
              title: 'Inference value',
              evaluate: (d) => {
                const splitLabel = this.splitChartKey(d.key, data.length);
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              },
            },
            {
              title: 'Feature value',
              evaluate: (d) => d.value.x,
            },
            {
              title: 'Score',
              evaluate: (d) => valueFormatter(d.value.y),
            },
          ];
          // If there is more than 1 model, show model number tooltip
          if (data.length >= 2) {
            toolTipColumns.push({
              title: 'Model',
              evaluate: (d) => {
                const label = this.splitChartKey(d.key, data.length);
                return label.model;
              },
            });
          }

          const holder = document.createElement('div');
          holder.classList.add('pd-holder');
          const chart = document.createElement('vz-bar-chart');
          chart.colorScale = new Plottable.Scales.Color().range(
            this.pdPlotColors
          );
          chart.linesColorScale = new Plottable.Scales.Color().range(
            this.pdPlotTransparentColors
          );
          chart.data = mapped;
          chart.lines = lines;
          chart.tooltipColumns = toolTipColumns;
          holder.appendChild(chart);

          const yLabel = document.createElement('div');
          yLabel.classList.add('pd-y-label');
          yLabel.innerText = this.isRegression_(this.modelType)
            ? 'Inference value'
            : 'Inference score';
          holder.appendChild(yLabel);

          return holder;
        },

        splitChartKey: function(labelKey, numberOfModels) {
          // If there is model key split it, otherwise just return original
          // label (index i) (model m) -> label (index #), m
          let keyToChart = labelKey;
          let modelToChart = '';
          if (numberOfModels >= 2) {
            const indexOfModelStr = labelKey.indexOf('(model');
            keyToChart = labelKey.substring(0, indexOfModelStr);
            modelToChart = labelKey.substring(
              indexOfModelStr + 7,
              labelKey.lastIndexOf(')')
            );
          }
          return {label: keyToChart, model: modelToChart};
        },

        formatChartKey: function(labelKey, modelInd, numberOfModels) {
          if (numberOfModels == 1) {
            return labelKey;
          } else {
            return labelKey + ' (model ' + this.getModelName_(modelInd) + ')';
          }
        },

        makeLineChart: function(featureName, data) {
          // numerical data:
          // {"0" (model id):
          //     {"1" (label): [{"step": 19.0, "scalar": 0.09157766401767},
          //        {"step": 23.444444444444443, "scalar": 0.10299546271562}]}}

          const holder = document.createElement('div');
          holder.classList.add('pd-holder');
          const chart = document.createElement('vz-line-chart2');
          const colorScale = [];
          const thresholdSeries = [];
          const valueFormatter = vz_chart_helpers.multiscaleFormatter(
            vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION
          );
          const formatValueOrNaN = function(x) {
            return Number.isNaN(x) ? 'NaN' : valueFormatter(x);
          };
          if (this.modelType == 'classification') {
            chart.defaultYRange = [0, 1];
          }
          const toolTipColumns = [
            {
              title: 'Inference value',
              evaluate: (d) => {
                const splitLabel = this.splitChartKey(
                  d.dataset.metadata().name,
                  data.length
                );
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              },
            },
            {
              title: 'Feature value',
              evaluate: (d) => formatValueOrNaN(d.datum.step),
            },
            {
              title: 'Score',
              evaluate: (d) => formatValueOrNaN(d.datum.scalar),
            },
          ];
          // If there is more than 1 model, show model number tooltip
          if (data.length >= 2) {
            toolTipColumns.push({
              title: 'Model',
              evaluate: (d) => {
                const label = this.splitChartKey(
                  d.dataset.metadata().name,
                  data.length
                );
                return label.model;
              },
            });
          }
          chart.tooltipColumns = toolTipColumns;

          const allSeries = [];
          let colorIndex = 0;
          for (let modelInd = 0; modelInd < data.length; modelInd++) {
            const modelData = data[modelInd];
            const series = _.keys(modelData);
            colorIndex = modelInd * series.length;
            series.forEach((label) => {
              colorScale.push(this.pdPlotColors[colorIndex++]);
              const thisLabel = this.formatChartKey(
                label,
                modelInd,
                data.length
              );
              chart.setSeriesData(thisLabel, modelData[label]);
              allSeries.push(thisLabel);
            });
            // Make a series for the current value of the feature to show in the
            // plot.
            colorIndex = modelInd * series.length;
            if (!this.globalPdPlots) {
              const origValEntry = this.createPdEntryForCurrentValue(
                featureName,
                modelData,
                modelInd
              );
              if (origValEntry) {
                const showKey = this.formatChartKey(
                  _.keys(modelData)[0] + ' - original value ',
                  modelInd,
                  data.length
                );
                chart.setSeriesData(showKey, [origValEntry]);
                allSeries.push(showKey);
                colorScale.push(this.pdPlotColors[colorIndex].brighter());
              }
            }
            if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
              const label = this.formatChartKey(
                'classification threshold',
                modelInd,
                data.length
              );
              let keys = _.keys(data[0]);
              // If using a label vocab, then adjust the keys to get the right
              // label for the positive class. Keys is normally of size 1 as
              // only partial dependence plot info for the positive class in
              // binary classification is returned by the server. But in some
              // cases, there may be entries for both positive and negative
              // classes. In this case, if there is a label vocab, use it
              // to filter out the keys to only use the one for the positive
              // class, which is array index 1 in the label vocab.
              if (keys.length > 1 && this.labelVocab &&
                  this.labelVocab.length > 1) {
                keys = [this.labelVocab[1]];
              }
              const thresholdData = data[0][keys].map((point) => {
                return {
                  step: point.step,
                  scalar: this.overallThresholds[modelInd].threshold,
                };
              });
              colorScale.push(this.pdPlotTransparentColors[colorIndex]);
              chart.setSeriesData(label, thresholdData);
              thresholdSeries.push(label);
              allSeries.push(label);
            }
          }
          chart.colorScale = new Plottable.Scales.Color().range(colorScale);
          chart.xAxisFormatter = this.getSimpleAxisFormatter(
            this.axisPrecision
          );
          chart.yAxisFormatter = this.getSimpleAxisFormatter(
            this.axisPrecision
          );
          // Do not show tooltips for the lines indicating model threshold values.
          chart.seriesWithoutTooltips = thresholdSeries;
          chart.colorScale.domain(allSeries);
          chart.setVisibleSeries(allSeries);
          holder.appendChild(chart);

          const yLabel = document.createElement('div');
          yLabel.classList.add('pd-y-label');
          yLabel.innerText = this.isRegression_(this.modelType)
            ? 'Inference value'
            : 'Inference score';
          holder.appendChild(yLabel);
          const xLabel = document.createElement('div');
          xLabel.classList.add('pd-x-label');
          xLabel.innerText = featureName;
          holder.appendChild(xLabel);

          return holder;
        },

        /**
         * Helper for making a partial dependence plot entry for the current
         * value for a feature.
         */
        createPdEntryForCurrentValue: function(featureName, data, modelInd) {
          // Extract the class and feature value index from the key of the PD
          // chart data. In the standard case, we just need to look at the
          // first entry to find the initial value.
          const keys = _.keys(data);
          let key = keys[0];
          // If using a label vocab, then adjust the key to get the right
          // label for the positive class. In this case, the second entry
          // corresponds to the positive class.
          if (this.labelVocab && this.labelVocab.length > 1) {
            const possibleLabelKey = keys.indexOf(this.labelVocab[1]);
            if (possibleLabelKey !== -1) {
              key = [1];
            }
          }
          const indexOfIndexStr = key.indexOf('index');
          let classToChart = +key;
          let indexForValue = 0;
          if (indexOfIndexStr > -1) {
            classToChart = +key.substring(0, key.indexOf(' '));
            indexForValue = +key.substring(
              indexOfIndexStr + 6,
              key.indexOf(')')
            );
          }

          let origValue = this.visdata[this.selected[0]][featureName];
          if (Array.isArray(origValue)) {
            origValue = origValue[indexForValue];
          }

          const inferences = this.selectedExampleAndInference.inferences[
            this.selectedExampleAndInference.inferences.length - 1
          ][modelInd];
          let origInferenceScore = -1;
          for (let i = 0; i < inferences.length; i++) {
            if (
              inferences[i].label == classToChart.toString() ||
              inferences[i].label == ''
            ) {
              origInferenceScore = inferences[i].score;
              break;
            }
          }
          if (origInferenceScore == -1) {
            return null;
          }
          return {step: origValue, scalar: origInferenceScore};
        },

        deletePdPlotProgress: function(featureName) {
          const container = this.featureContainerByName(featureName);
          const elements = container.querySelectorAll('paper-progress');
          for (let i = 0; i < elements.length; i++) {
            deleteElement(elements[i]);
          }
        },

        makeChartForFeature: function(chartType, featureName, data) {
          this.deletePdPlotProgress(featureName);
          // A separate chart per feature index for features with multiple values
          data.forEach((subfeature) =>
            this.addChart(chartType, featureName, subfeature)
          );
        },

        /**
         * Handler for getting partial dependence plot information for a given
         * feature.
         */
        getInferenceVisualization: function(featureName, event) {
          // The range of x-values to interpolate over for numerical features.
          const xMin = this.getUniqueByEvent(event, '.x-min').value;
          const xMax = this.getUniqueByEvent(event, '.x-max').value;

          // For a numerical feature with many repeated values, we allow users to
          // restrict inference to a smaller range of indices by using a pattern
          // (e.g. "0,2,4-6" runs inference for indices 0, 2, 4, 5, 6).
          const featureIndexPattern = this.getUniqueByEvent(
            event,
            '.feature-index-pattern'
          ).value;

          const urlParams = {
            feature_name: featureName,
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            x_min: xMin,
            x_max: xMax,
            feature_index_pattern: featureIndexPattern,
            example_index: this.globalPdPlots ? -1 : this.selected[0],
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };

          // Call into backend.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/infer_mutants',
              urlParams
            );
            const chartMakerCallback = (result) => {
              return this.makeChartForFeature(
                result.value.chartType,
                featureName,
                result.value.data
              );
            };
            const chartErrorCallback = () => {
              return this.handleChartErrorForFeature(featureName);
            };
            this.makeAsyncRequest_(
              url,
              chartMakerCallback.bind(this),
              null,
              'Plot creation',
              chartErrorCallback.bind(this)
            );
          } else {
            this.fire('infer-mutants', urlParams);
          }

          // Show progress bar while the plot is being calculated.
          const container = this.featureContainerByName(
            featureName
          ).querySelector('.tf-category-pane-content');
          const progress = document.createElement('paper-progress');
          progress.setAttribute('indeterminate', true);
          progress.setAttribute('class', 'pdplot-progress');
          Polymer.dom(container).appendChild(progress);
        },

        handleChartErrorForFeature: function(featureName) {
          // Remove the feature from pending queue, so it can be called again.
          const featureInd = this.partialDepPlotPendingFeatures.indexOf(
            featureName
          );
          if (featureInd > -1) {
            this.partialDepPlotPendingFeatures.splice(featureInd, 1);
          }
          // Delete the progress bar.
          this.deletePdPlotProgress(featureName);
        },

        shouldHideFeatureIndicesSelector: function(featureName, selected) {
          if (
            !selected ||
            selected.length == 0 ||
            !this.visdata ||
            this.visdata.length <= selected[0]
          ) {
            return true;
          }
          const item = this.visdata[selected[0]];
          return !Array.isArray(item[featureName]);
        },

        /** Check if pd-input-container has any elements in it and hide it if it
        does not*/
        shouldHidePdInputContainer: function(item, selected) {
          if (
            !this.shouldHideFeatureIndicesSelector(item.name, selected) ||
            !item.samples
          ) {
            return false;
          } else {
            return true;
          }
        },

        /** Returns the feature container associated with the feature name. */
        featureContainerByName: function(featureName) {
          return this.$$('[data-feature-name="' + featureName + '"]');
        },

        /** Return the feature container associated with the specific event. */
        featureContainerByEvent: function(event) {
          let el = event.target;
          while (!el.classList.contains('feature-container')) {
            el = el.parentNode;
          }
          return el;
        },

        /** Gets the selector within .feature-container for the event. */
        getUniqueByEvent(event, selector) {
          return this.featureContainerByEvent(event).querySelector(selector);
        },

        partialDepPlotEligibleFeaturesSet: function(features) {
          this.isSortingEligibleFeatures = false;
          if (!features || features.length == 0) {
            return;
          }
          // Open up the first PD plot pane after the category panes have loaded.
          setTimeout(() => {
            if (this.$$('.pd-entry-container').hidden) {
              this.$$('.tf-category-pane').click();
            }
          }, 100);
        },

        /**
         * Handler for click on button to generate partial dependence plots for
         * a feature.
         */
        categoryPaneClicked: function(event) {
          const featureContainer = this.featureContainerByEvent(event);

          const element = featureContainer.querySelector('.pd-entry-container');

          if (element.hasAttribute('hidden')) {
            this.drawPdCharts_(event);
            this.showPdElement_(featureContainer);
          } else {
            this.hidePdElement_(featureContainer);
          }
        },

        /**
         * Handler for drawing partial dependence plots for a feature.
         */
        drawPdCharts_: function(event) {
          // Make sure the feature wasn't already requested.
          const featureName = event.model.get('item').name;
          if (this.partialDepPlotPendingFeatures.indexOf(featureName) > -1) {
            return;
          }
          this.partialDepPlotPendingFeatures.push(featureName);

          this.getInferenceVisualization(featureName, event);
        },

        /**
         * Handler for clearing the partial dependence plots for a feature.
         */
        clearPdElementCharts_: function(element) {
          // Delete all the charts.
          const charts = element.querySelectorAll('.pd-holder');
          charts.forEach(function(chart) {
            deleteElement(chart);
          });
        },

        /**
         * Handler for closing the partial dependence plots holder for a feature.
         */
        hidePdElement_: function(featureContainer) {
          // Clear the plots
          const element = featureContainer.querySelector('.pd-entry-container');
          this.clearPdElementCharts_(element);
          element.setAttribute('hidden', true);
          // Handle icon
          const icon = featureContainer.querySelector('.pd-row-arrow');
          icon.classList.remove('normal-icon');
          icon.classList.add('rotated-icon');
          // Handle row style
          const row = featureContainer.querySelector('.perf-table-entry');
          row.classList.add('perf-table-row');
          row.classList.remove('perf-table-row-expanded');
        },

        showPdElement_: function(featureContainer) {
          const element = featureContainer.querySelector('.pd-entry-container');
          element.removeAttribute('hidden');
          // Handle icon
          const icon = featureContainer.querySelector('.pd-row-arrow');
          icon.classList.add('normal-icon');
          icon.classList.remove('rotated-icon');
          // Handle row style
          const row = featureContainer.querySelector('.perf-table-entry');
          row.classList.remove('perf-table-row');
          row.classList.add('perf-table-row-expanded');
        },

        hideAllPdElements_: function() {
          const elements = Polymer.dom(this.root).querySelectorAll(
            '.feature-container'
          );
          for (let i = 0; i < elements.length; i++) {
            this.hidePdElement_(elements[i]);
          }
        },

        pdInputChanged: function(event) {
          // Create a new object with the members of the event that are used
          // in PD plot creation so that the eventual handler can use the
          // correct information. Without creating this event copy, the target
          // information will be incorrect by the time the PD plot uses the
          // event object due to how the browser uses the event object.
          const clonedEventInfo = {
            target: event.target,
            model: event.model,
          };
          // Debounce a refresh request, for when multiple updates are happening
          // in succession.
          this.debounce(
            'pdInputChangedDebounce',
            () => this.pdInputChangedImpl(clonedEventInfo),
            500
          );
        },

        /**
         * Handler for changes in settings for a partial dependence plot.
         */
        pdInputChangedImpl: function(event) {
          // Hide all existing plots so they can be regenerated with the new
          // settings.
          const element = this.getUniqueByEvent(
            event,
            '.tf-category-pane-content'
          );
          this.clearPdElementCharts_(element);
          // Draw new plots
          this.drawPdCharts_(event);
        },

        /**
         * Populates the partial dependence plots area for a selected example.
         */
        populatePdTabs: function() {
          // First hide all existing PD plots before refreshing.
          this.hideAllPdElements_();

          // Call into the backend to get the possible features to show plots for.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/eligible_features',
              {}
            );
            const setEligibleFields = (result) => {
              this.set('partialDepPlotEligibleFeatures', result.value);
            };
            this.makeAsyncRequest_(url, setEligibleFields, null, 'Plot setup');
          } else {
            this.fire('get-eligible-features');
          }
        },

        sortPdFeatures_: function() {
          // First hide all existing PD plots before refreshing.
          this.hideAllPdElements_();
          const urlParams = {
            example_index: this.globalPdPlots ? -1 : this.selected[0],
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };
          this.isSortingEligibleFeatures = true;
          // Call into the backend to sort the possible features to show plots for.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/sort_eligible_features',
              urlParams
            );
            const setEligibleFields = (result) => {
              this.set('partialDepPlotEligibleFeatures', result.value);
            };
            const sortErrorCallback = () => {
              this.isSortingEligibleFeatures = false;
            };
            this.makeAsyncRequest_(
              url,
              setEligibleFields,
              null,
              'Plot ordering',
              sortErrorCallback.bind(this)
            );
          } else {
            urlParams['features'] = this.partialDepPlotEligibleFeatures;
            this.fire('sort-eligible-features', urlParams);
          }
        },
        shouldDisableSortFeaturesButton: function(
          partialDepPlotEligibleFeatures,
          isSortingEligibleFeatures
        ) {
          // Do not show "sort features by interestingness" button if sorting is
          // currently occuring or there are no features to sort.
          return (
            isSortingEligibleFeatures ||
            partialDepPlotEligibleFeatures == null ||
            partialDepPlotEligibleFeatures.length == 0
          );
        },

        toggleTrueLabelSetup: function() {
          this.$.collapsetruelabel.toggle();
        },

        toggleExplorerSetup: function() {
          this.$$('#collapseexplorer').toggle();
        },

        toggleContextTools: function() {
          this.$.collapsecontexttools.toggle();
        },

        togglePerformance: function() {
          this.$.collapseperformance.toggle();
        },

        toggleInferenceResults: function() {
          this.$$('#collapseinference').toggle();
        },

        getExpandCollapseIcon: function(opened) {
          return opened ? 'expand-less' : 'expand-more';
        },

        getExpandCollapsePerfIconClass: function(opened) {
          return opened ? 'normal-icon' : 'rotated-icon';
        },

        getPerfTableRowClass: function(opened) {
          return opened ? 'perf-table-row-expanded' : 'perf-table-row';
        },

        getPerfTableModelClass: function(numModels) {
          return numModels < 2 ? 'perf-table-model-single' : 'perf-table-model';
        },

        getDatapointEditorTitle: function(selectedExampleNum, comparedIndices) {
          return this.getSectionTitle(
            'Edit',
            selectedExampleNum,
            comparedIndices
          );
        },

        getInferTitle: function(selectedExampleNum, comparedIndices) {
          return this.getSectionTitle(
            'Infer',
            selectedExampleNum,
            comparedIndices
          );
        },

        getSectionTitle: function(title, selectedExampleNum, comparedIndices) {
          let name = title;
          if (selectedExampleNum != null && selectedExampleNum !== '') {
            if (comparedIndices != null && comparedIndices.length > 0) {
              name +=
                ' - Datapoints ' +
                selectedExampleNum +
                ' and ' +
                comparedIndices[0];
            } else {
              name += ' - Datapoint ' + selectedExampleNum;
            }
          }
          return name;
        },

        /**
         * Expands/collapses a row in the performance table based on a click.
         */
        togglePerfRow: function(event) {
          // Find the table index for which the click was made.
          let el = event.target;
          while (el != null && !el.dataset.index) {
            el = el.parentNode;
          }
          if (el == null) {
            return;
          }
          const index = el.dataset.index;

          // Toggle the appropriate 'opened' variable in the list
          // that backs the performance table.
          this.set(
            'featureValueThresholds.' + index + '.opened',
            !this.featureValueThresholds[index].opened
          );

          // If expanding a section, update inference stats to ensure
          // properly rendered ROC curve.
          if (this.featureValueThresholds[index].opened) {
            requestAnimationFrame(() => this.updateInferenceStats_(true));
          }
        },

        getPerformanceTabTitle: function(modelType, multiClass) {
          return this.isBinaryClassification_(modelType, multiClass)
            ? 'Performance & Fairness'
            : 'Performance';
        },

        getPerfTableTitle: function(
          feature1,
          feature2,
          optimization,
          thresholds
        ) {
          let str = this.getPrintableOptimizationName(optimization);
          if (feature1 == null || feature1.length == 0) {
            if (optimization == 'custom') {
              return 'Explore overall performance';
            } else {
              return str;
            }
          } else {
            let featStr = feature1;
            if (feature2 != null && feature2.length != 0) {
              featStr += '/' + feature2;
            }
            return str + ' for ' + thresholds.length + ' values of ' + featStr;
          }
        },

        getNoThresholdPerfTableTitle: function(feature1, feature2, thresholds) {
          if (feature1 == null || feature1.length == 0) {
            return 'Explore overall performance';
          } else {
            let str = feature1;
            if (feature2 != null && feature2.length != 0) {
              str += '/' + feature2;
            }
            return str + ' (' + thresholds.length + ' values)';
          }
        },

        getPrintableOptimizationName: function(optimization) {
          if (optimization == 'custom') {
            return 'Custom thresholds';
          } else if (optimization == 'unaware') {
            return 'Optimal single threshold';
          } else if (optimization == 'demoparity') {
            return 'Demographic parity thresholds';
          } else if (optimization == 'equalopp') {
            return 'Equal opportunity thresholds';
          } else if (optimization == 'equalacc') {
            return 'Equal accuracy thresholds';
          } else {
            return 'Optimal group thresholds';
          }
        },

        getFeatureSortBy: function(modelType, multiClass) {
          let sorts = ['Count', 'Alphabetical'];
          if (this.isBinaryClassification_(modelType, multiClass)) {
            sorts = sorts.concat([
              'Accuracy',
              'False positives',
              'False negatives',
            ]);
          } else if (this.isMultiClass_(modelType, multiClass)) {
            sorts = sorts.concat(['Accuracy']);
          } else {
            sorts = sorts.concat([
              'Mean error',
              'Median error',
              'Mean absolute error',
              'Median absolute error',
              'Mean squared error',
              'Median squared error',
            ]);
          }
          return sorts;
        },

        selectedFeatureSortChanged_: function(sort) {
          const temp = this.featureValueThresholds;
          this.featureValueThresholds = [];
          this.featureValueThresholds = this.sortFeatureValues(temp);

          if (this.regressionEntries_ != null) {
            const temp = this.regressionEntries_;
            this.regressionEntries_ = [];
            this.regressionEntries_ = this.sortRegressionEntries(temp);
          }
        },

        getSliderClass: function(index) {
          let str = 'slider ';
          str += index == 0 ? 'slider-model-one' : 'slider-model-two';
          return str;
        },

        formatError: function(error) {
          return d3.format('.3f')(error);
        },

        expandAllPerformance: function() {
          if (this.featureValueThresholds == null) {
            return;
          }
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            this.set('featureValueThresholds.' + i + '.opened', true);
          }
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        collapseAllPerformance: function() {
          if (this.featureValueThresholds == null) {
            return;
          }
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            this.set('featureValueThresholds.' + i + '.opened', false);
          }
        },

        getPerfTableEntryClass: function(eligibleFeature) {
          let str = 'perf-table-entry perf-table-row ';
          // If interestingness is set to 0 then display this feature as
          // trivial.
          if (
            'interestingness' in eligibleFeature &&
            eligibleFeature['interestingness'] == 0
          ) {
            str += 'perf-table-entry-trivial';
          }
          return str;
        },

        getFacetedAttributions: function(
            facetedMeanAttributions, featureValueThreshold) {
          const key = this.getPrintableValue_(featureValueThreshold);
          return facetedMeanAttributions[key];
        },

        getRegressionAttributions: function(key) {
          if (key === 'All datapoints') {
            return this.meanAttributions_;
          }
          return this.facetedMeanAttributions_[key];
        },
      });

      // TODO(#2338): Remove this, and set up a "no TF" message properly.
      // Keep this in sync with `frontend_metadata` in
      // `interactive_inference_plugin.py`.
      tf_tensorboard.registerDashboard({
        plugin: PLUGIN_NAME,
        elementName: 'wit-dashboard',
        tabName: 'What-If Tool',
      });
    })();
  </script>
</dom-module>
